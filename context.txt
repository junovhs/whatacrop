üõ°Ô∏è SYSTEM MANDATE: THE WARDEN PROTOCOL
ROLE: High-Integrity Systems Architect (NASA/JPL Standard).
CONTEXT: You are coding inside a strict environment enforced by Warden.

THE 3 LAWS (Non-Negotiable):

1. LAW OF ATOMICITY
   - Files: MUST be < 2000 tokens.
   - Action: Split immediately if larger.

2. LAW OF COMPLEXITY
   - Cyclomatic Complexity: MUST be ‚â§ 10 per function.
   - Nesting Depth: MUST be ‚â§ 4 levels.
   - Function Arguments: MUST be ‚â§ 5 parameters.

3. LAW OF PARANOIA
   - Use Result<T, E> for I/O and fallible operations.
   - NO .unwrap() or .expect() calls.

OUTPUT FORMAT (MANDATORY):

When providing code files, use this exact format:

1. Declare ALL files first:

<delivery>
path/to/file1.rs
path/to/file2.rs [NEW]
</delivery>

2. Provide EACH file:

<file path='path/to/file1.rs'>
[complete file contents]
</file>

RULES:
- Every file in <delivery> MUST have a matching <file> block
- Do NOT use markdown code blocks - use <file> tags only
- Do NOT truncate files
- Paths must match exactly

The `warden apply` command will REJECT incomplete deliveries.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
BEGIN CODEBASE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

<file path="LICENSE">
MIT License

Copyright (c) 2025 Spencer Nunamaker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# crop ‚Äî lilapps production asset prep tool

A tiny, fast, professional-grade browser tool for turning any image into production-ready assets.

No sign-ups. No ads. No bullshit. Just drop, frame, export.

Born from a real workflow: as marketers, designers, and devs, we constantly pull images from ‚ÄúLocation A‚Äù (vendor sites, Google, screenshots, internal decks) and need them adapted for ‚ÄúLocation B‚Äù (website hero, email header, slider, blog card, social thumb, etc.). Firing up heavy design software for these small but frequent tasks is a massive, repeating tax.

`crop` exists to erase that tax.

You are already in the browser. You drag or paste the image. You set or pick the frame. You get exactly the sizes you need. Fast, precise, and pleasant.

This document outlines:
- Current behavior and priorities
- UX and interaction principles
- Vision: evolving from ‚Äúcrop tool‚Äù into the world‚Äôs best browser-native production asset prep tool
- Future capabilities (artboards, variants, dev/URL integration, etc.)

All while remaining a small, focused, ‚Äúlilapps‚Äù-style product.

---

## Core Principles

1. Instant
   - Loads fast.
   - Drag-and-drop or paste to start.
   - No accounts, no onboarding wall, no clutter.

2. In-browser and trustworthy
   - All processing client-side.
   - No image uploads to a server.
   - No tracking garbage.
   - Safe for work assets and client materials.

3. Single-screen, single-purpose
   - One focused workspace.
   - No multi-page project system.
   - No trying to be Canva, Figma, or Photoshop.

4. Production-minded
   - Targeted at real, recurring jobs:
     - Website heroes, cards, sliders
     - Social posts and thumbnails
     - Email headers and imagery
     - Presentation and doc assets
   - Defaults and presets are practical, not ornamental.

5. Tiny, perfect, extensible
   - Minimal codebase.
   - Carefully chosen features.
   - Everything added must:
     - Reduce friction.
     - Increase reliability.
     - Stay understandable at a glance.

---

## Current Feature Set

These features exist or are in active development based on the current implementation:

- Global drag-and-drop:
  - Drop an image anywhere to start.
  - If an image is already loaded, drop anywhere to replace it.
  - Clear overlay hint: ‚ÄúDrop image to start‚Äù / ‚ÄúDrop image to replace.‚Äù

- Core cropping:
  - Full-viewport canvas.
  - Draggable crop area.
  - Corner handles and edge handles for resizing.
  - Minimum crop size enforced.
  - Crop constrained to image bounds.

- Aspect ratios:
  - Quick-select buttons:
    - Free
    - 1:1, 4:3, 3:2, 5:4, 16:9, 9:16, 21:9
  - Custom aspect ratio:
    - Inline input (`W:H`) reduced to simplest form.
    - Applies immediately and locks resizing to that ratio.

- Presets:
  - Social presets (examples):
    - Instagram square, portrait, story
    - Facebook posts and covers
    - X / Twitter posts and headers
    - YouTube thumbnails and frames
  - Document/print presets:
    - A4, Letter, etc. at sensible resolutions.
  - Presets apply both:
    - Crop aspect ratio.
    - Suggested export size.

- Export controls:
  - Numeric width/height fields.
  - Export aligned with current crop and/or active preset.
  - Auto-adjust dimensions to maintain locked aspect when relevant.
  - Export via canvas to a downloadable file.
  - Sensible default filenames:
    - Includes reduced aspect, size, timestamp.

- Smart viewport behavior:
  - Image auto-fits into viewport with margins.
  - When crop changes, the image recenters smoothly around the crop (commit animation).
  - ResizeObserver-driven layout updates.

- State handling:
  - Internal modes:
    - Free
    - Aspect-locked
    - Pixel preset
    - Custom pixel
  - Assertions, clamping, and validation throughout for robust behavior.

- Grid overlay:
  - Rule-of-thirds guide rendered inside the crop.
  - Toggleable.

These pieces already form a serious, high-quality cropping experience.

---

## Immediate UX Enhancements (Planned)

All planned enhancements preserve the simplicity of the UI while making the behavior feel ‚Äúobvious‚Äù to non-technical users.

1. Mode simplification (user-facing)
   - Internally keep modes. Externally present:
     - Free
     - Locked ratio (via aspect buttons)
     - Preset size (via dropdowns)
   - Users never need to think in terms of ‚Äúmodes‚Äù; they just:
     - Select a ratio ‚Üí crop locks.
     - Select a preset ‚Üí frame + export size align.
     - Manually override ‚Üí gracefully fall back to ‚ÄúCustom‚Äù or ‚ÄúFree‚Äù as appropriate.

2. Drag-and-drop polish
   - Ensure consistent behavior:
     - Drop anywhere = load (if empty) or replace (if existing).
   - Maintain relative crop where sensible when replacing images.
   - Clear, minimal overlays and hints.

3. Legibility and ergonomics
   - Slightly larger control typography.
   - Larger hit areas on handles and edges.
   - Subtle background refinement (dark, but not harsh) to focus the eye on content.

4. Undo / redo
   - Lightweight history for:
     - Crop changes
     - Aspect/preset changes
     - Export size adjustments
   - Standard shortcuts:
     - Ctrl/Cmd+Z, Ctrl/Cmd+Shift+Z.

---

## Vision: From Crop Tool to Production Asset Prep Tool

`crop` is evolving into:

‚ÄúThe world‚Äôs best browser-native production asset prep tool for people who ship things online.‚Äù

Designed for:
- Marketers who need many formats from one idea.
- Social/content teams creating consistent visuals.
- Web devs and designers enforcing image standards.
- Indie founders and studios preparing launch and campaign assets.

Key: this remains a small, single-purpose lilapp. No bloat. Just a more powerful definition of ‚Äúprep.‚Äù

---

## Strategic Feature Pillars

### 1. Artboard / Frame Mode

The foundational concept for everything else.

- Lock a frame:
  - Choose a preset or custom size ‚Üí that becomes the fixed output frame (artboard).
- Move image, not frame:
  - Pan, zoom, rotate the underlying image within the locked frame.
- Always export at frame size:
  - Guarantees exact, repeatable dimensions.

Why:
- Matches how real-world placements work (hero slots, ad units, thumbnails).
- Becomes the base for responsive/variant logic.

Status:
- High priority. This becomes the primary interaction model when presets are used.

---

### 2. Variants: Design Once, Export Many (Auto-Variant System)

This is the flagship innovation.

Problem:
- The same visual concept must exist in many sizes:
  - 16:9 cover, 1:1 thumb, 9:16 story, email header, etc.
- Today, that work is repetitive and manual.

Goal:
- Let users define a single master composition and generate multiple size variants with minimal extra work.
- Stay deterministic and understandable (no black-box ‚ÄúAI auto layouts‚Äù).

Concept:
- Master layout:
  - User designs one frame (artboard) with:
    - Background image (cropped/positioned).
    - Future: logo, simple text, or extra shapes (when layers arrive).
- Variant frames:
  - User selects a set of target sizes (e.g., ‚ÄúSocial pack,‚Äù ‚ÄúAd set‚Äù).
  - Each variant:
    - Shares the master composition via simple rules:
      - How backgrounds scale.
      - How focal points align.
      - How overlays pin to corners/edges.
    - Can be gently tweaked per-variant when needed.

Principles:
- Small, predictable rule set:
  - Pinning (e.g., top-left, centered).
  - Scaling:
    - Fixed-size or relative to frame.
  - Optional overrides.
- Visual clarity:
  - Show all variants as a list or small strip.
  - Quick flip between them.
  - ‚ÄúExport all‚Äù in one click.

This system:
- Turns `crop` into a serious time-saver for campaigns and launches.
- Stays aligned with the lilapps ethos by using a minimal, carefully designed rule model instead of a heavy layout engine.

---

### 3. High-Confidence Export (Format and Quality Intelligence)

`crop` should quietly ‚Äúdo the right thing‚Äù with file formats.

Planned:
- Export formats:
  - PNG
  - JPEG
  - WebP
- Simple quality presets:
  - Crisp (high quality)
  - Balanced (recommended)
  - Tiny (for email/low-bandwidth)
- Intention-based labeling:
  - ‚ÄúOptimized for web‚Äù
  - ‚ÄúOptimized for email‚Äù
  - ‚ÄúPreserve sharp edges (logos/UI)‚Äù
- Under the hood:
  - sRGB normalization.
  - Smart defaults for photos vs. graphics.
  - Respect for transparency when needed.

Outcome:
- Users trust that exports are:
  - The right size.
  - The right format.
  - Reasonably optimized without manual tuning.

---

### 4. Micro Adjustments (Prep-Grade, Not Filter-Grade)

Goal:
- Only adjustments that serve readability and layout.

Planned:
- Subtle, controlled sliders:
  - Brightness
  - Contrast
  - Saturation
  - Optional: blur (e.g., for background plates)
- Designed for:
  - Making text-over-image placements cleaner.
  - Making assets consistent, not ‚Äústylized.‚Äù

No filter gimmicks. Strictly production utility.

---

### 5. Layers and Simple Compositing (Future)

Acknowledged future direction (not immediate):

- Support multiple images/elements:
  - Background image(s)
  - Logos
  - Decorative shapes or panels
  - Eventually minimal text blocks
- Presented as:
  - A very small, clear layer stack.
- Integrated with:
  - Artboard mode.
  - Variant rules (symbols-style behavior).

This will be tackled cautiously to preserve simplicity.

---

### 6. Text (Back Burner, By Design)

Text is powerful but complex.

Position:
- Will not be rushed.
- When implemented:
  - Minimal, structured:
    - Headline blocks, small labels.
  - Treated as layout elements, not a generic rich text editor.
- Must integrate cleanly with variants and artboards.

Until then:
- Focus is on framing and exporting great backplates and image-led assets.

---

### 7. Dev and URL-Based Control (Tooling for Teams)

`crop` should be delightful for non-technical users and quietly powerful for devs and system thinkers.

Planned capabilities:
- URL-driven presets:
  - Examples:
    - `croptool.app/968x600-MyHero`
    - `croptool.app/1280x720-YouTubeThumb`
  - On load:
    - Preconfigures frame size, labels, and behavior.
- Optional query parameters (introduced carefully):
  - Format (`fmt=jpg`)
  - Quality preset (`q=balanced`)
  - Grid visibility
  - Preset packs (`preset=social-basic`)
  - Variant sets (`variant=all`)
- Local favorites:
  - Save a few custom presets in-browser:
    - Names, sizes, aspect ratios.

Result:
- Teams can:
  - Standardize image prep with shareable links.
  - Embed ‚ÄúEdit in crop‚Äù links in docs and repos.
- Power users get an automation surface without affecting normal users.

---

## Non-Goals

To protect the product‚Äôs clarity and quality, `crop` is explicitly NOT:

- A full design suite
- A template marketplace
- A collaboration platform
- A complex video editor (video support, if any, will be extremely focused and considered separately)
- A bloated, growth-hacked SaaS product

If a feature does not:
- Make asset prep faster,
- Improve consistency,
- Or increase confidence in the output,

it does not belong.

---

## Summary

`crop` started as ‚ÄúI just want a better way to crop.‚Äù It is evolving into:

- A polished, trustworthy, minimal tool for:
  - Framing,
  - Resizing,
  - Lightly adjusting,
  - And intelligently exporting

marketing and product visuals at the speed of real work.

It stays small. It stays sharp. It feels like cheating compared to firing up a full design suite for simple, constant, production tasks.
</file>

<file path="cropLogic.js">
"use strict";

function loadImageFile(file) {
  if (!file) {
    console.error("loadImageFile: no file provided");
    return;
  }

  assert(file instanceof File, "loadImageFile: not a File object");

  renderLoadingView();

  const hadPrev = !!state.image;
  const prev = hadPrev
    ? {
        x: state.crop.x,
        y: state.crop.y,
        w: state.crop.w,
        h: state.crop.h,
        imgW: state.fullImage?.naturalWidth || state.image.naturalWidth,
        imgH: state.fullImage?.naturalHeight || state.image.naturalHeight,
      }
    : null;

  const reader = new FileReader();

  reader.onerror = () => {
    console.error("loadImageFile: FileReader error", reader.error);
    alert("Failed to read file");
    initAppView();
  };

  reader.onload = (e) => {
    const img = new Image();

    img.onerror = () => {
      console.error("loadImageFile: Image load error");
      alert("Failed to load image");
      initAppView();
    };

    img.onload = () => {
      assert(img.naturalWidth > 0, "loadImageFile: invalid image width");
      assert(img.naturalHeight > 0, "loadImageFile: invalid image height");
      assert(
        img.naturalWidth <= MAX_CANVAS_DIM,
        "loadImageFile: image width exceeds max",
      );
      assert(
        img.naturalHeight <= MAX_CANVAS_DIM,
        "loadImageFile: image height exceeds max",
      );

      const fullImage = img;
      const maxDim = Math.max(fullImage.naturalWidth, fullImage.naturalHeight);

      const finishLoad = (displayImage, previewScaleFactor) => {
        state.fullImage = fullImage;
        state.image = displayImage;
        state.previewScale = previewScaleFactor;

        if (hadPrev && prev && prev.imgW > 0 && prev.imgH > 0) {
          preserveRelativeCrop(prev, fullImage);
        } else {
          resetCropToFull(fullImage);
        }

        clearAllSelections();
        state.committing = false;
        if (state.commitTimer) {
          clearTimeout(state.commitTimer);
          state.commitTimer = null;
        }

        // --- HISTORY INIT START ---
        initHistory();
        pushHistory("Initial Load");
        // --- HISTORY INIT END ---

        renderCropView();

        requestAnimationFrame(() => {
          fitImageToViewport();
          requestRender();
        });
      };

      if (maxDim > PREVIEW_MAX_DIM) {
        const scale = PREVIEW_MAX_DIM / maxDim;
        const previewW = Math.round(fullImage.naturalWidth * scale);
        const previewH = Math.round(fullImage.naturalHeight * scale);

        const previewCanvas = document.createElement("canvas");
        previewCanvas.width = previewW;
        previewCanvas.height = previewH;
        const pctx = previewCanvas.getContext("2d");
        pctx.drawImage(fullImage, 0, 0, previewW, previewH);

        const previewImg = new Image();
        previewImg.onload = () =>
          finishLoad(
            previewImg,
            fullImage.naturalWidth / previewImg.naturalWidth,
          );
        previewImg.onerror = () => {
          console.error("loadImageFile: Preview creation failed");
          alert("Failed to process large image");
          initAppView();
        };
        previewImg.src = previewCanvas.toDataURL();
        return;
      }

      finishLoad(fullImage, 1);
    };

    img.src = e.target.result;
  };

  reader.readAsDataURL(file);
}

function preserveRelativeCrop(prev, img) {
  assert(prev, "preserveRelativeCrop: no prev");
  assert(img, "preserveRelativeCrop: no img");

  const relX = prev.x / prev.imgW;
  const relY = prev.y / prev.imgH;
  const relW = prev.w / prev.imgW;
  const relH = prev.h / prev.imgH;

  const newW = relW * img.naturalWidth;
  const newH = relH * img.naturalHeight;
  const newX = relX * img.naturalWidth;
  const newY = relY * img.naturalHeight;

  state.crop = {
    x: clamp(newX, 0, Math.max(0, img.naturalWidth - newW)),
    y: clamp(newY, 0, Math.max(0, img.naturalHeight - newH)),
    w: Math.max(MIN_CROP, Math.min(newW, img.naturalWidth)),
    h: Math.max(MIN_CROP, Math.min(newH, img.naturalHeight)),
  };

  validateCrop(state.crop);
}

function resetCropToFull(img) {
  assert(img, "resetCropToFull: no img");

  state.crop = {
    x: 0,
    y: 0,
    w: img.naturalWidth,
    h: img.naturalHeight,
  };

  validateCrop(state.crop);
}

function startDrag(e, handle) {
  if (!state.image) return;
  if (!handle) return;

  assert(typeof handle === "string", "startDrag: handle must be string");

  e.preventDefault();
  e.stopPropagation();

  beginInteract();

  const overlay = document.getElementById("crop-overlay");
  if (overlay) overlay.classList.add("dragging");

  state.drag = {
    handle,
    startScreen: { x: e.clientX, y: e.clientY },
    startCrop: { ...state.crop },
    startTransform: { ...state.imageTransform },
  };

  assert(state.drag.startScreen.x !== undefined, "startDrag: invalid clientX");

  window.addEventListener("mousemove", handleDrag);
  window.addEventListener("mouseup", endDrag);
}

function handleDrag(e) {
  if (!state.drag || !state.image) return;

  const currentScale = state.baseScale * state.zoom;
  assert(currentScale > 0, "handleDrag: invalid scale");

  const dxScreen = e.clientX - state.drag.startScreen.x;
  const dyScreen = e.clientY - state.drag.startScreen.y;

  if (state.drag.handle === "move") {
    const next = { ...state.drag.startCrop };
    const dxImage = (dxScreen / currentScale) * state.previewScale;
    const dyImage = (dyScreen / currentScale) * state.previewScale;
    moveCrop(next, dxImage, dyImage);
    state.crop = next;
  } else if (state.drag.handle.startsWith("pan-")) {
    state.imageTransform.tx = state.drag.startTransform.tx + dxScreen;
    state.imageTransform.ty = state.drag.startTransform.ty + dyScreen;
  } else {
    const next = { ...state.drag.startCrop };
    const dxImage = (dxScreen / currentScale) * state.previewScale;
    const dyImage = (dyScreen / currentScale) * state.previewScale;
    const aspectRatio =
      state.mode === MODE.ASPECT_RATIO ||
      state.mode === MODE.PIXEL_PRESET ||
      state.mode === MODE.CUSTOM_PIXEL
        ? state.aspectRatio
        : 0;
    resizeCrop(next, state.drag.handle, dxImage, dyImage, aspectRatio);
    state.crop = next;
  }

  requestRender();
}

function endDrag() {
  if (!state.drag) return;

  const overlay = document.getElementById("crop-overlay");
  if (overlay) overlay.classList.remove("dragging");

  const handle = state.drag.handle;
  state.drag = null;

  window.removeEventListener("mousemove", handleDrag);
  window.removeEventListener("mouseup", endDrag);

  // --- HISTORY PUSH START ---
  if (handle !== "pan-image") {
    pushHistory("Crop Interact");
    scheduleCommit();
  } else {
    pushHistory("Pan Image");
  }
  // --- HISTORY PUSH END ---
}

function resetCrop() {
  if (!state.image) return;
  beginInteract();
  const targetImg = state.fullImage || state.image;
  resetCropToFull(targetImg);
  validateCrop(state.crop);
  clearAllSelections();
  zoomToFit(true);

  // --- HISTORY PUSH ---
  pushHistory("Reset Crop");

  scheduleCommit();
}

function newImage() {
  if (state.commitTimer) clearTimeout(state.commitTimer);
  state.image = null;
  state.fullImage = null;
  state.previewScale = 1;
  clearAllSelections();
  state.committing = false;
  initAppView();
}
</file>

<file path="cropResize.js">
"use strict";

function moveCrop(crop, dx, dy) {
  const img = state.fullImage || state.image;
  assert(img, "moveCrop: no image");
  assert(typeof crop.x === "number", "moveCrop: invalid crop x");

  crop.x = clamp(crop.x + dx, 0, img.naturalWidth - crop.w);
  crop.y = clamp(crop.y + dy, 0, img.naturalHeight - crop.h);

  validateCrop(crop);
}

function resizeCrop(crop, handle, dx, dy, aspectRatio) {
  const img = state.fullImage || state.image;
  assert(img, "resizeCrop: no image");
  assert(typeof handle === "string", "resizeCrop: handle must be string");
  assert(typeof aspectRatio === "number", "resizeCrop: aspect must be number");

  const locked = aspectRatio > 0;
  const limits = { mw: img.naturalWidth, mh: img.naturalHeight };

  if (locked) {
    if (handle.length === 2) {
      resizeLockedCorner(crop, handle, dx, dy, aspectRatio, limits);
    } else {
      resizeLockedEdge(crop, handle, dx, dy, aspectRatio, limits);
    }
  } else {
    resizeFree(crop, handle, dx, dy, limits);
  }

  validateCrop(crop);
}

function resizeFree(crop, handle, dx, dy, limits) {
  const { mw, mh } = limits;

  if (handle.includes("n")) {
    const newH = clamp(crop.h - dy, MIN_CROP, crop.y + crop.h);
    crop.y += crop.h - newH;
    crop.h = newH;
  }
  if (handle.includes("s")) {
    crop.h = clamp(crop.h + dy, MIN_CROP, mh - crop.y);
  }
  if (handle.includes("w")) {
    const newW = clamp(crop.w - dx, MIN_CROP, crop.x + crop.w);
    crop.x += crop.w - newW;
    crop.w = newW;
  }
  if (handle.includes("e")) {
    crop.w = clamp(crop.w + dx, MIN_CROP, mw - crop.x);
  }
}

function resizeLockedCorner(crop, handle, dx, dy, aspect, limits) {
  // 1. Determine direction signs (-1 or 1)
  const dirX = handle.includes("w") ? -1 : 1;
  const dirY = handle.includes("n") ? -1 : 1;

  // 2. Vector Projection: Project the mouse delta onto the Aspect Ratio Diagonal.
  // This prevents jitter/axis-switching by using both dx and dy contributions.
  // Formula: deltaW = (dx*dirX + dy*dirY/aspect) / (1 + 1/aspect^2)

  // Terms derived from dot product of MouseVector and DiagonalVector
  const numerator = dx * dirX + (dy * dirY) / aspect;
  const denominator = 1 + 1 / (aspect * aspect);

  const wChange = numerator / denominator;

  const proposedW = Math.max(MIN_CROP, crop.w + wChange);
  const proposedH = proposedW / aspect;

  applyLockedConstraint(crop, proposedW, proposedH, dirX, dirY, limits, aspect);
}

function resizeLockedEdge(crop, handle, dx, dy, aspect, limits) {
  // For edges, we don't need projection because movement is 1D.
  // dirX/dirY define the "Growth Direction" relative to center.
  // 0 means it grows symmetrically from center on that axis.
  let dirX = 0;
  let dirY = 0;
  let proposedW = crop.w;
  let proposedH = crop.h;

  if (handle === "n") {
    dirY = -1; // Grows Up
    proposedH = Math.max(MIN_CROP, crop.h - dy);
    proposedW = proposedH * aspect;
  } else if (handle === "s") {
    dirY = 1; // Grows Down
    proposedH = Math.max(MIN_CROP, crop.h + dy);
    proposedW = proposedH * aspect;
  } else if (handle === "w") {
    dirX = -1; // Grows Left
    proposedW = Math.max(MIN_CROP, crop.w - dx);
    proposedH = proposedW / aspect;
  } else if (handle === "e") {
    dirX = 1; // Grows Right
    proposedW = Math.max(MIN_CROP, crop.w + dx);
    proposedH = proposedW / aspect;
  }

  applyLockedConstraint(crop, proposedW, proposedH, dirX, dirY, limits, aspect);
}

function applyLockedConstraint(
  crop,
  proposedW,
  proposedH,
  dirX,
  dirY,
  limits,
  aspect,
) {
  const { mw, mh } = limits;

  // 1. Calculate Available Space based on the Anchor Point.
  // The "Anchor" is the side/point of the box that DOESN'T move.
  // crop.x/y/w/h here are from the START of the drag (stable reference).

  let maxAvailableW = Infinity;
  let maxAvailableH = Infinity;

  // X Constraints
  if (dirX === -1) {
    // Anchor is Right Edge. Max Width = Right Edge position.
    maxAvailableW = crop.x + crop.w;
  } else if (dirX === 1) {
    // Anchor is Left Edge. Max Width = Image Width - Left Edge position.
    maxAvailableW = mw - crop.x;
  } else {
    // Anchor is Center. Max Width = 2 * (Distance from Center to nearest vertical edge).
    const cx = crop.x + crop.w / 2;
    maxAvailableW = Math.min(cx, mw - cx) * 2;
  }

  // Y Constraints
  if (dirY === -1) {
    maxAvailableH = crop.y + crop.h;
  } else if (dirY === 1) {
    maxAvailableH = mh - crop.y;
  } else {
    const cy = crop.y + crop.h / 2;
    maxAvailableH = Math.min(cy, mh - cy) * 2;
  }

  // 2. Determine Limiting Dimension
  // The box must fit within BOTH maxAvailableW and maxAvailableH.
  // We normalize maxAvailableH to width-units to find the bottleneck.
  const maxW_from_H = maxAvailableH * aspect;
  const maxW = Math.min(maxAvailableW, maxW_from_H);

  // 3. Clamp proposed size
  let finalW = Math.min(proposedW, maxW);
  let finalH = finalW / aspect;

  // 4. Calculate Final Position
  let newX = crop.x;
  let newY = crop.y;

  if (dirX === -1)
    newX = crop.x + crop.w - finalW; // Anchor Right
  else if (dirX === 1)
    newX = crop.x; // Anchor Left
  else newX = crop.x + crop.w / 2 - finalW / 2; // Anchor Center

  if (dirY === -1)
    newY = crop.y + crop.h - finalH; // Anchor Bottom
  else if (dirY === 1)
    newY = crop.y; // Anchor Top
  else newY = crop.y + crop.h / 2 - finalH / 2; // Anchor Center

  // 5. Commit
  // We use strict clamping at the very end to correct any tiny float errors
  crop.w = finalW;
  crop.h = finalH;
  crop.x = clamp(newX, 0, mw - finalW);
  crop.y = clamp(newY, 0, mh - finalH);
}
</file>

<file path="cropTransform.js">
"use strict";

function fitImageToViewport() {
  const img = state.image;
  assert(img, "fitImageToViewport: no image");
  assert(state.viewport.w > 0, "fitImageToViewport: invalid viewport width");
  assert(state.viewport.h > 0, "fitImageToViewport: invalid viewport height");

  const imgW = img.naturalWidth;
  const imgH = img.naturalHeight;
  const marginW = state.viewport.w * CENTER_MARGIN * 2;
  const marginH = state.viewport.h * CENTER_MARGIN * 2;

  const scale = Math.min(
    1,
    (state.viewport.w - marginW) / imgW,
    (state.viewport.h - marginH) / imgH,
  );
  const tx = (state.viewport.w - imgW * scale) / 2;
  const ty = (state.viewport.h - imgH * scale) / 2;

  assert(scale > 0, "fitImageToViewport: scale must be positive");

  state.baseScale = scale;
  state.zoom = 1.0;
  state.imageTransform.tx = tx;
  state.imageTransform.ty = ty;
}

function recalculateLayout() {
  if (!state.image) return;
  const { w: oldVpW, h: oldVpH } = state.viewport;
  const { tx: oldTx, ty: oldTy } = state.imageTransform;
  const oldBaseScale = state.baseScale;
  const oldZoom = state.zoom;

  const viewport = document.getElementById("viewport");
  if (!viewport) return;
  state.viewport.w = viewport.clientWidth;
  state.viewport.h = viewport.clientHeight;

  const oldScale = oldBaseScale * oldZoom;
  const centerX_img = (oldVpW / 2 - oldTx) / oldScale;
  const centerY_img = (oldVpH / 2 - oldTy) / oldScale;

  const img = state.image;
  const marginW = state.viewport.w * CENTER_MARGIN * 2;
  const marginH = state.viewport.h * CENTER_MARGIN * 2;
  const newBaseScale = Math.min(
    1,
    (state.viewport.w - marginW) / img.naturalWidth,
    (state.viewport.h - marginH) / img.naturalHeight,
  );
  state.baseScale = newBaseScale;

  const newScale = newBaseScale * oldZoom;
  const newTx = state.viewport.w / 2 - centerX_img * newScale;
  const newTy = state.viewport.h / 2 - centerY_img * newScale;

  animateToTransform({ tx: newTx, ty: newTy }, true);
}

function computeCenteredTransform() {
  const img = state.image;
  if (!img || !state.viewport.w || !state.viewport.h) return null;

  const { x, y, w, h } = state.crop;
  const { tx, ty } = state.imageTransform;
  const currentScale = state.baseScale * state.zoom;

  assert(currentScale > 0, "computeCenteredTransform: invalid scale");
  validateCrop(state.crop);

  const cropCxOnPreview = (x + w / 2) / state.previewScale;
  const cropCyOnPreview = (y + h / 2) / state.previewScale;
  const cropCxScreen = tx + cropCxOnPreview * currentScale;
  const cropCyScreen = ty + cropCyOnPreview * currentScale;

  const viewportCx = state.viewport.w / 2;
  const viewportCy = state.viewport.h / 2;

  let dx = viewportCx - cropCxScreen;
  let dy = viewportCy - cropCyScreen;

  const marginX = state.viewport.w * CENTER_MARGIN;
  const marginY = state.viewport.h * CENTER_MARGIN;
  const left = tx + (x / state.previewScale) * currentScale + dx;
  const top = ty + (y / state.previewScale) * currentScale + dy;
  const right = left + (w / state.previewScale) * currentScale;
  const bottom = top + (h / state.previewScale) * currentScale;

  if (left < marginX) dx += marginX - left;
  if (right > state.viewport.w - marginX)
    dx -= right - (state.viewport.w - marginX);
  if (top < marginY) dy += marginY - top;
  if (bottom > state.viewport.h - marginY)
    dy -= bottom - (state.viewport.h - marginY);

  return { tx: tx + dx, ty: ty + dy };
}

function animateToTransform(target, immediate = false) {
  if (!target) return;
  if (immediate) {
    if (target.tx !== undefined) state.imageTransform.tx = target.tx;
    if (target.ty !== undefined) state.imageTransform.ty = target.ty;
    if (target.zoom !== undefined) state.zoom = target.zoom;
    requestRender();
    return;
  }

  state.committing = true;
  requestRender();

  setTimeout(() => {
    if (target.tx !== undefined) state.imageTransform.tx = target.tx;
    if (target.ty !== undefined) state.imageTransform.ty = target.ty;
    if (target.zoom !== undefined) state.zoom = target.zoom;
    requestRender();

    setTimeout(() => {
      state.committing = false;
      requestRender();
    }, TRANSITION_MS + 30);
  }, 16);
}

function scheduleCommit() {
  if (state.commitTimer) clearTimeout(state.commitTimer);

  state.commitTimer = setTimeout(() => {
    state.commitTimer = null;
    if (!state.image) return;
    const target = computeCenteredTransform();
    animateToTransform(target);
  }, COMMIT_DELAY);
}

function setZoom(targetZoom, focalPoint) {
  const newZoom = clamp(targetZoom, MIN_ZOOM, MAX_ZOOM);
  if (Math.abs(newZoom - state.zoom) < EPSILON) return;

  const s1 = state.baseScale * state.zoom;
  const s2 = state.baseScale * newZoom;
  const { tx: tx1, ty: ty1 } = state.imageTransform;
  const { x: fx, y: fy } = focalPoint;

  const ix = (fx - tx1) / s1;
  const iy = (fy - ty1) / s1;

  const tx2 = fx - ix * s2;
  const ty2 = fy - iy * s2;

  animateToTransform({ tx: tx2, ty: ty2, zoom: newZoom }, true);
}

function zoomToFit(immediate = false) {
  if (!state.image) return;
  const { w: cropW, h: cropH } = state.crop;
  const cropDisplayW = cropW / state.previewScale;
  const cropDisplayH = cropH / state.previewScale;

  const marginW = state.viewport.w * CENTER_MARGIN * 2;
  const marginH = state.viewport.h * CENTER_MARGIN * 2;

  const targetZoom = Math.min(
    (state.viewport.w - marginW) / cropDisplayW / state.baseScale,
    (state.viewport.h - marginH) / cropDisplayH / state.baseScale,
  );

  const target = computeCenteredTransform();
  if (target) {
    animateToTransform({ ...target, zoom: targetZoom }, immediate);
  }
}

function zoomToActual(immediate = false) {
  if (!state.image) return;

  const targetZoom = state.previewScale / state.baseScale;

  const focalPoint = { x: state.viewport.w / 2, y: state.viewport.h / 2 };
  const s1 = state.baseScale * state.zoom;
  const s2 = state.baseScale * targetZoom;
  const { tx: tx1, ty: ty1 } = state.imageTransform;
  const { x: fx, y: fy } = focalPoint;
  const ix = (fx - tx1) / s1;
  const iy = (fy - ty1) / s1;
  const targetTx = fx - ix * s2;
  const targetTy = fy - iy * s2;

  animateToTransform(
    { tx: targetTx, ty: targetTy, zoom: targetZoom },
    immediate,
  );
}

function beginInteract() {
  if (state.commitTimer) clearTimeout(state.commitTimer);
  state.committing = false;
  requestRender();
}

function applyAspectToCrop(ratio) {
  const img = state.fullImage || state.image;
  assert(img, "applyAspectToCrop: no image");
  assert(ratio > 0, "applyAspectToCrop: ratio must be positive");
  validateAspectRatio(ratio);

  const imgW = img.naturalWidth;
  const imgH = img.naturalHeight;
  let w, h;
  if (imgW / imgH > ratio) {
    h = imgH;
    w = h * ratio;
  } else {
    w = imgW;
    h = w / ratio;
  }

  assert(w > 0 && w <= imgW, "applyAspectToCrop: invalid width");
  assert(h > 0 && h <= imgH, "applyAspectToCrop: invalid height");

  state.crop = { x: (imgW - w) / 2, y: (imgH - h) / 2, w, h };
  validateCrop(state.crop);
}
</file>

<file path="exporter.js">
"use strict";

function exportImage() {
  if (!state.image) {
    console.warn("exportImage: no image loaded");
    return;
  }
  const wInput = document.getElementById("export-w");
  const hInput = document.getElementById("export-h");
  if (!wInput || !hInput) {
    console.error("exportImage: missing export inputs");
    return;
  }
  const w = parseInt(wInput.value, 10);
  const h = parseInt(hInput.value, 10);
  if (!(w > 0 && h > 0)) {
    console.warn("exportImage: invalid export dimensions");
    alert("Please enter valid export dimensions");
    return;
  }
  validatePixelDimension(w);
  validatePixelDimension(h);
  const sourceImage = state.fullImage || state.image;
  const { x, y, w: cropW, h: cropH } = state.crop;
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = w;
  exportCanvas.height = h;
  const ctx = exportCanvas.getContext("2d");
  if (!ctx) {
    console.error("exportImage: failed to get canvas context");
    return;
  }
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(sourceImage, x, y, cropW, cropH, 0, 0, w, h);
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
  const g = gcd(w, h);
  const aspectW = w / g;
  const aspectH = h / g;
  const filename = `crop_${w}x${h}_${aspectW}-${aspectH}_${timestamp}.png`;
  exportCanvas.toBlob((blob) => {
    if (!blob) {
      console.error("exportImage: failed to create blob");
      alert("Export failed");
      return;
    }
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.click();
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }, "image/png");
}

function syncExportInputsToCrop() {
  if (!state.image) return;

  const wInput = document.getElementById("export-w");
  const hInput = document.getElementById("export-h");
  if (!wInput || !hInput) return;

  const { w, h } = state.crop;
  const actualW = Math.round(w);
  const actualH = Math.round(h);

  if (state.exportW && state.exportH) {
    wInput.value = state.exportW;
    hInput.value = state.exportH;
  } else {
    wInput.value = String(actualW);
    hInput.value = String(actualH);
  }
}

function onExportInput(dimension, value) {
  if (!state.image) return;

  const val = parseInt(value, 10);
  if (isNaN(val) || val <= 0) return;

  const wInput = document.getElementById("export-w");
  const hInput = document.getElementById("export-h");
  if (!wInput || !hInput) return;

  const locked =
    state.mode === MODE.ASPECT_RATIO ||
    state.mode === MODE.PIXEL_PRESET ||
    state.mode === MODE.CUSTOM_PIXEL;

  if (locked && state.aspectRatio > 0) {
    if (dimension === "w") {
      state.exportW = String(val);
      const newH = Math.round(val / state.aspectRatio);
      state.exportH = String(newH);
      hInput.value = String(newH);
    } else {
      state.exportH = String(val);
      const newW = Math.round(val * state.aspectRatio);
      state.exportW = String(newW);
      wInput.value = String(newW);
    }
  } else {
    if (dimension === "w") {
      state.exportW = String(val);
    } else {
      state.exportH = String(val);
    }
  }

  updateScaleIndicator();
}
</file>

<file path="history.js">
"use strict";

const MAX_HISTORY = 50;

function initHistory() {
  state.history = [];
  state.historyIndex = -1;
}

function pushHistory(label) {
  // If we are in the middle of the stack (undid some steps),
  // chop off the future. We are creating a new timeline.
  if (state.historyIndex < state.history.length - 1) {
    state.history = state.history.slice(0, state.historyIndex + 1);
  }

  const snapshot = createSnapshot();

  // Deduplication: Don't push if it's identical to the current tip
  // This happens sometimes with minor mouse jitters or rapid clicks
  if (state.historyIndex >= 0) {
    const current = state.history[state.historyIndex];
    if (areSnapshotsEqual(current, snapshot)) return;
  }

  state.history.push(snapshot);

  // Bound the stack size (Circular buffer-ish behavior)
  if (state.history.length > MAX_HISTORY) {
    state.history.shift();
  } else {
    state.historyIndex++;
  }

  console.log(
    `[History] Pushed: ${label} (${state.historyIndex + 1}/${state.history.length})`,
  );
}

function undo() {
  if (state.historyIndex <= 0) {
    console.warn("[History] Nothing to undo");
    return;
  }

  state.historyIndex--;
  const prev = state.history[state.historyIndex];
  restoreSnapshot(prev);
  requestRender();
}

function redo() {
  if (state.historyIndex >= state.history.length - 1) {
    console.warn("[History] Nothing to redo");
    return;
  }

  state.historyIndex++;
  const next = state.history[state.historyIndex];
  restoreSnapshot(next);
  requestRender();
}

function createSnapshot() {
  // Deep copy only what affects the visual output
  return {
    crop: { ...state.crop },
    imageTransform: { ...state.imageTransform },
    mode: state.mode,
    aspectRatio: state.aspectRatio,
    exportW: state.exportW,
    exportH: state.exportH,
    activePresetKey: state.activePresetKey,
    // We don't track zoom/pan in history usually, but we DO track
    // imageTransform if we want to undo pans. Let's track it all.
    timestamp: Date.now(),
  };
}

function restoreSnapshot(snap) {
  if (!snap) return;

  state.crop = { ...snap.crop };
  state.imageTransform = { ...snap.imageTransform };

  // Restore modes and flags
  state.mode = snap.mode;
  state.aspectRatio = snap.aspectRatio;
  state.exportW = snap.exportW;
  state.exportH = snap.exportH;
  state.activePresetKey = snap.activePresetKey;

  // Re-run validation to ensure UI stays synced
  validateCrop(state.crop);

  // UI Updates
  updateAspectUI();
  updatePresetTriggers();
  syncExportInputsToCrop();

  // Trigger a smooth re-center if the crop jumped significantly
  // or just let renderFrame handle it. For undo, instant is usually better.
}

function areSnapshotsEqual(a, b) {
  // Fast comparison for critical values
  return (
    Math.abs(a.crop.x - b.crop.x) < EPSILON &&
    Math.abs(a.crop.y - b.crop.y) < EPSILON &&
    Math.abs(a.crop.w - b.crop.w) < EPSILON &&
    Math.abs(a.crop.h - b.crop.h) < EPSILON &&
    a.mode === b.mode &&
    Math.abs(a.aspectRatio - b.aspectRatio) < EPSILON
  );
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Image Crop Tool</title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <div id="app"></div>

        <!-- Load in dependency order -->
        <script src="state.js"></script>
        <script src="history.js"></script>
        <script src="cropTransform.js"></script>
        <script src="cropResize.js"></script>
        <script src="cropLogic.js"></script>
        <script src="viewPresets.js"></script>
        <script src="viewAspect.js"></script>
        <script src="view.js"></script>
        <script src="exporter.js"></script>
        <script src="main.js"></script>
    </body>
</html>
</file>

<file path="main.js">
"use strict";

document.addEventListener("DOMContentLoaded", () => {
  initAppView();
  setupGlobalDrop();
});

function setupGlobalDrop() {
  let dragDepth = 0;
  const MAX_DRAG_DEPTH = 100;

  ["dragenter", "dragleave", "dragover", "drop"].forEach((type) => {
    document.addEventListener(type, (e) => {
      if (!e.dataTransfer || !e.dataTransfer.types) return;

      const hasFiles = Array.from(e.dataTransfer.types).includes("Files");
      if (!hasFiles) return;

      e.preventDefault();

      if (type === "dragenter") {
        dragDepth += 1;

        if (dragDepth > MAX_DRAG_DEPTH) {
          console.warn("setupGlobalDrop: drag depth exceeded, resetting");
          dragDepth = MAX_DRAG_DEPTH;
        }

        showDropHint();
      } else if (type === "dragleave") {
        dragDepth = Math.max(0, dragDepth - 1);
        if (dragDepth === 0) hideDropHint();
      } else if (type === "drop") {
        dragDepth = 0;
        hideDropHint();
        handleFileDrop(e);
      }
    });
  });
}

function handleFileDrop(e) {
  const dt = e.dataTransfer;

  if (!dt || !dt.files || dt.files.length === 0) {
    console.warn("handleFileDrop: no files in drop");
    return;
  }

  const file = dt.files[0];

  if (!file || !file.type || !file.type.startsWith("image/")) {
    console.warn("handleFileDrop: not an image file");
    return;
  }

  if (state.image) {
    loadImageFile(file);
    return;
  }

  const dropZone = document.getElementById("drop-zone");
  if (!dropZone) {
    loadImageFile(file);
    return;
  }

  const rect = dropZone.getBoundingClientRect();
  const x = e.clientX;
  const y = e.clientY;

  if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
    loadImageFile(file);
  }
}

function showDropHint() {
  let hint = document.getElementById("global-drop-hint");

  if (!hint) {
    hint = document.createElement("div");
    hint.id = "global-drop-hint";
    hint.className = "global-drop-hint";
    document.body.appendChild(hint);
  }

  hint.textContent = state.image
    ? "Drop image to replace"
    : "Drop image to start";
  hint.classList.add("visible");
}

function hideDropHint() {
  const hint = document.getElementById("global-drop-hint");
  if (!hint) return;

  hint.classList.remove("visible");

  setTimeout(() => {
    if (hint.parentNode && !hint.classList.contains("visible")) {
      hint.parentNode.removeChild(hint);
    }
  }, 150);
}
</file>

<file path="next-steps-notes.md">
Yeah, you‚Äôre absolutely running into ‚Äúphysics of the browser‚Äù territory here üòÑ

Short version:

* A **10k‚Äì20kpx canvas** is *insanely* heavy.
* Your current code is doing a couple of things that make it much worse. 
* The way to make it feel buttery smooth is to **separate ‚Äúpreview‚Äù from ‚Äúfull-res‚Äù** instead of trying to interact with the full 20k√ó20k image directly.

Let me walk through what‚Äôs going on and what you can do.

---

## 1. Why 10k+ feels stuttery (in your actual code)

From your `renderFrame()`:

```js
const img = state.image;
canvas.width = img.naturalWidth;
canvas.height = img.naturalHeight;
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(img, 0, 0);
```

Then you apply a CSS transform to scale it into the viewport. 

That means:

* A 10k √ó 10k canvas = **100,000,000 pixels**.
* At 4 bytes per pixel (RGBA), that‚Äôs ~400 MB of pixel data‚Ä¶ every time you resize / reallocate.
* You‚Äôre doing both:

  * **Huge canvas dimensions**, *and*
  * **Redrawing the whole image** every frame as the user drags/resizes the crop.

Plus, your `MAX_CANVAS_DIM` is `16384`, which mirrors typical GPU texture limits. A **20k √ó 20k** canvas is literally above what many GPUs will allow in a single texture. 

So: it‚Äôs not that your JS is ‚Äútoo weak‚Äù; it‚Äôs that you‚Äôre asking the browser to push a brick wall.

---

## 2. The real solution: preview vs full-res

The pattern professional tools use is:

> **Small, super-fast preview for interaction**
> **Full-resolution source only for export**

You‚Äôre already doing the second half correctly in `exportImage()` ‚Äî you create a separate offscreen canvas sized to the export and draw from `state.image` there. 

What you need is:

### Step A ‚Äì Keep two images

* `state.fullImage` ‚Üí the original, 20k√ó20k monster
* `state.previewImage` (or just reuse `state.image`) ‚Üí a downscaled copy used *only for UI drawing*

When you load an image in `loadImageFile`:

```js
const PREVIEW_MAX_DIM = 4096; // or 8192, tune as needed

function loadImageFile(file) {
  // ...your existing FileReader logic...

  img.onload = () => {
    const imgW = img.naturalWidth;
    const imgH = img.naturalHeight;

    state.fullImage = img; // always keep original

    const maxDim = Math.max(imgW, imgH);
    if (maxDim <= PREVIEW_MAX_DIM) {
      state.image = img;
      state.previewScale = 1;
    } else {
      const scale = PREVIEW_MAX_DIM / maxDim;
      const w = Math.round(imgW * scale);
      const h = Math.round(imgH * scale);

      const previewCanvas = document.createElement("canvas");
      previewCanvas.width = w;
      previewCanvas.height = h;
      const pctx = previewCanvas.getContext("2d");
      pctx.drawImage(img, 0, 0, w, h);

      const previewImg = new Image();
      previewImg.onload = () => {
        state.image = previewImg;      // use this for UI
        state.previewScale = scale;    // link preview ‚Üí full-res
        // now do your existing crop init & render
        // preserveRelativeCrop/resetCropToFull, fitImageToViewport, requestRender, etc.
      };
      previewImg.src = previewCanvas.toDataURL("image/png");
    }
  };
}
```

Now all your **interactive stuff** (`renderFrame`, drag, resize) runs against a **much smaller image**, e.g. 4k instead of 20k.

### Step B ‚Äì Keep crop coords in preview space, export from full-res

Right now your crop is in `state.crop` and assumed to be in `state.image` pixel space. You can keep that ‚Äî just treat `state.image` as the preview.

Then, in `exportImage()`, when you actually draw the image to the offscreen canvas, convert the crop back into full-res coordinates:

```js
const scale = state.previewScale || 1; // 1 if already full-size

// crop in preview coords
const { x, y, w: cw, h: ch } = state.crop;

// source crop in full-res coords
const srcX = x / scale;
const srcY = y / scale;
const srcW = cw / scale;
const srcH = ch / scale;

ctx.drawImage(
  state.fullImage || state.image, // fall back just in case
  srcX, srcY, srcW, srcH,
  0, 0, w, h
);
```

Result:

* UI always manipulates a **small, fast texture**.
* Export still pulls from the **original full-res** image.
* You can happily open a 20k√ó20k source, and the browser only ever displays, say, 4096px max on the canvas.

This one change gets you **90% of the ‚Äúbuttery‚Äù feeling** you want.

---

## 3. Cheap wins inside your existing canvas logic

Even without going full preview/full-res right away, here are some easy improvements:

### Only resize/redraw the canvas when needed

In `renderFrame()`:

```js
if (canvas.width !== img.naturalWidth || canvas.height !== img.naturalHeight) {
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;
  ctx.drawImage(img, 0, 0);
}
// If the image itself hasn't changed, you often don't need to redraw each frame;
// you can sometimes just move the overlay.
```

This alone avoids reallocating that giant pixel buffer every frame.

### Don‚Äôt do heavy DOM work every frame

At the end of `renderFrame()` you call a bunch of functions that touch the DOM: `updateCropInfo()`, `updatePresetTriggers()`, `syncExportInputsToCrop()`, `updateScaleIndicator()`, `updateAspectBar()`. 

During a drag, you can:

* Update only what‚Äôs visually critical per frame (canvas + overlay).
* Throttle or postpone the ‚Äúinfo/preset bar‚Äù updates until pointerup / endDrag.

That reduces layout thrash while the mouse is moving.

---

## 4. ‚ÄúSomething extra‚Äù if you want to go fancy

If you want to really juice it beyond just browser APIs:

### OffscreenCanvas + Web Worker

* Use `OffscreenCanvas` to do the **preview generation and heavy resampling** in a worker.
* Main thread stays responsive; you just receive a ready-to-display bitmap.

### WebGL / WebGPU renderer

* Instead of `<canvas 2d>`, render the image as a textured quad in WebGL/WebGPU.
* You then:

  * Keep the image as a texture (or a set of tiles) on the GPU.
  * Let the GPU handle pan/zoom with transforms.
* This is basically how pro photo apps handle giant images, but it‚Äôs a bigger rewrite (and still doesn‚Äôt remove the 16k texture dimension limits ‚Äî you‚Äôd tile above that).

### WASM for high-quality exports

* For super high-quality downscaling/filters, you can use Rust/C++ ‚Üí WASM to do CPU-heavy resize/processing, then feed the result into a normal canvas for download.
* That‚Äôs icing on the cake once you‚Äôve got the preview/full-res split.

---

## 5. Reality check on 20k√ó20k

You *can* support **loading** a 20k√ó20k image and give a smooth UX.
You **cannot** reliably keep a 20k√ó20k canvas/texture live and animated on all machines without jank.

So the strategy is:

* **Always downsample for interaction (preview).**
* **Map crop back to original for export.**
* Stay within something like 4k‚Äì8k for any *interactive* canvas.

If you‚Äôd like, I can help sketch the exact patch set to:

* Add `fullImage`/`previewScale`
* Adjust `loadImageFile` + `exportImage`
* Keep the rest of your architecture basically intact.
</file>

<file path="state.js">
"use strict";

// Tunables
const MIN_CROP = 20;
const COMMIT_DELAY = 350;
const CENTER_MARGIN = 0.15;
const TRANSITION_MS = 500;
const MAX_CANVAS_DIM = 16384;
const EPSILON = 0.001;
const MAX_ASPECT_VALUE = 100;
const MAX_PIXEL_DIM = 50000;
const PREVIEW_MAX_DIM = 4096;
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 32.0;

const MODE = {
  NONE: "none",
  ASPECT_RATIO: "aspect-ratio",
  PIXEL_PRESET: "pixel-preset",
  CUSTOM_PIXEL: "custom-pixel",
};

const state = {
  image: null,
  fullImage: null,
  previewScale: 1,
  crop: { x: 0, y: 0, w: 0, h: 0 },
  viewport: { w: 0, h: 0 },
  imageTransform: { tx: 0, ty: 0 },
  baseScale: 1,
  zoom: 1,
  drag: null,
  committing: false,
  commitTimer: null,
  needsRender: false,
  mode: MODE.NONE,
  aspectRatio: 0,
  exportW: "",
  exportH: "",
  activePresetKey: null,
  presetLabels: {
    social: "Social Media",
    docs: "Documents",
    "custom-pixel": "Custom Pixels",
  },
  customAspectActive: false,
  customAspectW: "",
  customAspectH: "",
  customAspectLabel: "Custom",
  customPixelActive: false,
  customPixelW: "",
  customPixelH: "",
  showGrid: true,
  scaleFactor: 1,
  scaleLevel: "ok",
};

function assert(cond, msg) {
  if (!cond) throw new Error(`Assertion failed: ${msg}`);
}

function clamp(val, min, max) {
  assert(typeof val === "number", "clamp: val must be number");
  assert(typeof min === "number", "clamp: min must be number");
  assert(typeof max === "number", "clamp: max must be number");
  assert(min <= max, "clamp: min must be <= max");
  return Math.max(min, Math.min(max, val));
}

function getCropAspect() {
  const valid = state.crop.w > 0 && state.crop.h > 0;
  return valid ? state.crop.w / state.crop.h : 0;
}

function gcd(a, b) {
  assert(typeof a === "number", "gcd: a must be number");
  assert(typeof b === "number", "gcd: b must be number");
  let iterations = 0;
  const MAX_ITERATIONS = 1000;
  while (b !== 0 && iterations < MAX_ITERATIONS) {
    const t = b;
    b = a % b;
    a = t;
    iterations++;
  }
  assert(iterations < MAX_ITERATIONS, "gcd: exceeded iteration limit");
  return a;
}

function reduceRatio(w, h) {
  assert(typeof w === "number", "reduceRatio: w must be number");
  assert(typeof h === "number", "reduceRatio: h must be number");
  if (!(w > 0 && h > 0)) return { w: 0, h: 0 };
  const g = gcd(w, h) || 1;
  return { w: w / g, h: h / g };
}

function setMode(newMode) {
  assert(Object.values(MODE).includes(newMode), "setMode: invalid mode");
  state.mode = newMode;
}

function clearAllSelections() {
  state.mode = MODE.NONE;
  state.aspectRatio = 0;
  state.exportW = "";
  state.exportH = "";
  state.activePresetKey = null;
  state.customAspectActive = false;
  state.customAspectW = "";
  state.customAspectH = "";
  state.customAspectLabel = "Custom";
  state.customPixelActive = false;
  state.customPixelW = "";
  state.customPixelH = "";
  state.presetLabels.social = "Social Media";
  state.presetLabels.docs = "Documents";
  state.presetLabels["custom-pixel"] = "Custom Pixels";
}

function markPresetActive(key, label) {
  assert(typeof key === "string", "markPresetActive: key must be string");
  assert(typeof label === "string", "markPresetActive: label must be string");
  assert(key in state.presetLabels, "markPresetActive: invalid key");

  state.activePresetKey = key;

  if (key === "social") {
    state.presetLabels.social = label;
  } else if (key === "docs") {
    state.presetLabels.docs = label;
  } else if (key === "custom-pixel") {
    state.presetLabels["custom-pixel"] = label;
  }
}

function requestRender() {
  if (state.needsRender) return;
  state.needsRender = true;
  window.requestAnimationFrame(() => {
    state.needsRender = false;
    renderFrame();
  });
}

function validateCrop(crop) {
  assert(crop !== null, "validateCrop: crop is null");
  assert(typeof crop.x === "number", "validateCrop: x must be number");
  assert(typeof crop.y === "number", "validateCrop: y must be number");
  assert(typeof crop.w === "number", "validateCrop: w must be number");
  assert(typeof crop.h === "number", "validateCrop: h must be number");
  assert(crop.x >= -EPSILON, "validateCrop: x must be >= 0");
  assert(crop.y >= -EPSILON, "validateCrop: y must be >= 0");
  assert(crop.w >= MIN_CROP, "validateCrop: w must be >= MIN_CROP");
  assert(crop.h >= MIN_CROP, "validateCrop: h must be >= MIN_CROP");
  return true;
}

function validateAspectRatio(ratio) {
  assert(typeof ratio === "number", "validateAspectRatio: must be number");
  assert(ratio >= 0, "validateAspectRatio: must be >= 0");
  assert(ratio <= MAX_ASPECT_VALUE, "validateAspectRatio: exceeds max");
  return true;
}

function validatePixelDimension(dim) {
  assert(typeof dim === "number", "validatePixelDimension: must be number");
  assert(dim > 0, "validatePixelDimension: must be > 0");
  assert(dim <= MAX_PIXEL_DIM, "validatePixelDimension: exceeds max");
  assert(Number.isInteger(dim), "validatePixelDimension: must be integer");
  return true;
}
</file>

<file path="styles.css">
:root {
    --bg-color: #0d0d0d;
    --panel-bg: rgba(18, 18, 20, 0.95);
    --border-color: #2a2a2c;
    --border-subtle: #1a1a1c;
    --text-color: #e8e8e8;
    --text-muted-color: #888;
    --text-dark-color: #0a0a0a;
    --accent-color: #ffffff;
    --accent-hover: #f0f0f0;
    --button-bg: #1e1e20;
    --button-hover: #2a2a2c;
    --input-bg: #141416;
    --success-color: #6ccf6c;
    --warning-color: #e0c75a;
    --error-color: #ff6666;

    --font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    --font-mono: "SF Mono", "Monaco", "Cascadia Code", "Courier New", monospace;
    --font-size-xs: 10px;
    --font-size-sm: 11px;
    --font-size-md: 12px;
    --font-size-base: 13px;

    --spacing-xs: 4px;
    --spacing-sm: 6px;
    --spacing-md: 8px;
    --spacing-lg: 10px;
    --spacing-xl: 14px;

    --radius-sm: 4px;
    --radius-md: 6px;
    --radius-lg: 8px;
    --radius-pill: 20px;
    --transition-fast: 0.12s cubic-bezier(0.4, 0, 0.2, 1);
    --transition-base: 0.2s cubic-bezier(0.4, 0, 0.2, 1);

    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.4);
    --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.5);
    --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.6);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-family);
    background: var(--bg-color);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    font-size: var(--font-size-base);
    line-height: 1.4;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body::before {
    content: "";
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 1;
}

#app {
    width: 100vw;
    height: 100vh;
    position: relative;
    z-index: 2;
}

.viewport {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    cursor: grab;
}

.viewport:active {
    cursor: grabbing;
}

.viewport canvas {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    pointer-events: none;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
}

.canvas-committing {
    transition: transform 500ms cubic-bezier(0.33, 0, 0.17, 1);
}

.drop-zone,
.loading-view {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    color: var(--text-muted-color);
    font-size: 15px;
    font-weight: 500;
}

.drop-zone {
    cursor: pointer;
    transition: background 0.2s ease;
}

.drop-zone:hover,
.drop-zone.dragging {
    background: rgba(255, 255, 255, 0.02);
    color: var(--text-color);
}

/* CORNER ICON SYSTEM */
.corner-icon {
    position: fixed;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    cursor: pointer;
    color: var(--text-muted-color);
    transition: all var(--transition-fast);
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-sm);
    z-index: 100;
}

.corner-icon:hover {
    color: var(--text-color);
    background: var(--button-hover);
    border-color: var(--border-color);
    transform: scale(1.05);
}

.corner-icon.active {
    color: var(--accent-color);
    background: var(--button-hover);
    border-color: var(--accent-color);
}

.corner-icon-tl {
    top: var(--spacing-xl);
    left: var(--spacing-xl);
}

.corner-icon-tr {
    top: var(--spacing-xl);
    right: var(--spacing-xl);
}

.corner-icon-br {
    bottom: var(--spacing-xl);
    right: var(--spacing-xl);
}

/* INFO PILLS - TOP CENTER */
.info-pills {
    position: fixed;
    top: var(--spacing-xl);
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: var(--spacing-md);
    z-index: 100;
}

.info-pill {
    padding: 5px 11px;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-pill);
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    font-weight: 600;
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-sm);
    color: var(--text-color);
}

/* SLIDE-OUT PANELS */
.slide-panel {
    position: fixed;
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-lg);
    padding: var(--spacing-lg);
    z-index: 99;
    opacity: 0;
    pointer-events: none;
    transition: all var(--transition-base);
}

.slide-panel.visible {
    opacity: 1;
    pointer-events: auto;
}

.panel-aspect {
    top: 64px;
    left: var(--spacing-xl);
    transform: translateY(-10px);
}

.panel-aspect.visible {
    transform: translateY(0);
}

.panel-presets {
    top: 64px;
    right: var(--spacing-xl);
    transform: translateY(-10px);
}

.panel-presets.visible {
    transform: translateY(0);
}

.panel-export {
    bottom: 64px;
    right: var(--spacing-xl);
    transform: translateY(10px);
}

.panel-export.visible {
    transform: translateY(0);
}

/* BOTTOM BAR */
.bottom-bar {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    padding: var(--spacing-lg);
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-lg);
    z-index: 100;
}

.tool-group {
    display: flex;
    align-items: center;
    gap: 4px;
}

.tool-separator {
    width: 1px;
    height: 16px;
    background: var(--border-color);
    margin: 0 4px;
}

.zoom-group {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
}

#zoom-slider {
    -webkit-appearance: none;
    width: 100px;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    cursor: pointer;
    transition: background var(--transition-fast);
}

#zoom-slider:hover {
    background: var(--button-hover);
}

#zoom-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: var(--accent-color);
    border-radius: 50%;
    cursor: pointer;
    transition: transform var(--transition-fast);
}

#zoom-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
}

#zoom-slider::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: var(--accent-color);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    transition: transform var(--transition-fast);
}

#zoom-slider::-moz-range-thumb:hover {
    transform: scale(1.2);
}

#zoom-indicator {
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    font-weight: 600;
    min-width: 40px;
    text-align: center;
}

.tool-btn {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--button-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    cursor: pointer;
    color: var(--text-muted-color);
    transition: all var(--transition-fast);
}

.tool-btn:hover {
    color: var(--text-color);
    background: var(--button-hover);
    border-color: var(--border-color);
}

/* CROP OVERLAY */
.crop-overlay {
    position: absolute;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.92);
    pointer-events: none;
    transition: box-shadow var(--transition-base);
}

.crop-overlay.dragging {
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.95);
}

.crop-overlay.committing {
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.92);
    transition:
        left 500ms cubic-bezier(0.33, 0, 0.17, 1),
        top 500ms cubic-bezier(0.33, 0, 0.17, 1),
        width 500ms cubic-bezier(0.33, 0, 0.17, 1),
        height 500ms cubic-bezier(0.33, 0, 0.17, 1),
        box-shadow var(--transition-base);
}

.crop-area {
    position: absolute;
    inset: 0;
    cursor: move;
    pointer-events: auto;
}

.handle,
.edge {
    pointer-events: auto;
    transition: all var(--transition-fast);
}

.handle {
    position: absolute;
    width: 11px;
    height: 11px;
    background: var(--accent-color);
    border: 2px solid var(--bg-color);
    border-radius: 2px;
    box-shadow: var(--shadow-sm);
}

.handle:hover {
    width: 13px;
    height: 13px;
}

.handle.nw {
    top: -6px;
    left: -6px;
    cursor: nwse-resize;
}
.handle.ne {
    top: -6px;
    right: -6px;
    cursor: nesw-resize;
}
.handle.sw {
    bottom: -6px;
    left: -6px;
    cursor: nesw-resize;
}
.handle.se {
    bottom: -6px;
    right: -6px;
    cursor: nwse-resize;
}

.edge {
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    opacity: 0;
    transition: opacity var(--transition-fast);
}

.crop-overlay:hover .edge {
    opacity: 1;
}

.edge.n,
.edge.s {
    width: 36px;
    height: 5px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
    border-radius: 3px;
}

.edge.n {
    top: -3px;
}
.edge.s {
    bottom: -3px;
}

.edge.w,
.edge.e {
    width: 5px;
    height: 36px;
    top: 50%;
    transform: translateY(-50%);
    cursor: ew-resize;
    border-radius: 3px;
}

.edge.w {
    left: -3px;
}
.edge.e {
    right: -3px;
}

.grid-canvas {
    position: absolute;
    inset: 0;
    pointer-events: none;
}

/* PANEL CONTENT STYLES */
.aspect-pills {
    display: flex;
    flex-direction: column;
    gap: 3px;
}

.aspect-pill {
    padding: 6px 12px;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
    background: transparent;
    color: var(--text-muted-color);
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    font-weight: 600;
    transition: all var(--transition-fast);
    white-space: nowrap;
    text-align: left;
}

.aspect-pill:hover {
    color: var(--text-color);
    background: rgba(255, 255, 255, 0.05);
}

.aspect-pill.active {
    background: rgba(255, 255, 255, 0.12);
    color: var(--accent-color);
    border-color: rgba(255, 255, 255, 0.15);
}

.divider-h {
    height: 1px;
    background: var(--border-subtle);
    margin: 4px 0;
}

.export-size-inputs {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: var(--spacing-md);
}

.size-input {
    width: 70px;
    padding: 6px 8px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-subtle);
    background: var(--input-bg);
    color: var(--text-color);
    font-size: var(--font-size-md);
    text-align: center;
    font-family: var(--font-mono);
    font-weight: 600;
    transition: all var(--transition-fast);
}

.size-input:focus {
    outline: none;
    border-color: var(--accent-color);
}

.size-separator {
    color: var(--text-muted-color);
    font-family: var(--font-mono);
    font-weight: 600;
}

.export-action {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 10px 16px;
    background: var(--accent-color);
    color: var(--text-dark-color);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: var(--font-family);
    font-size: var(--font-size-sm);
    font-weight: 700;
    transition: all var(--transition-fast);
    box-shadow: var(--shadow-md);
}

.export-action:hover {
    background: var(--accent-hover);
    transform: translateY(-1px);
}

.preset-group-label {
    font-size: var(--font-size-xs);
    color: var(--text-muted-color);
    padding: 8px 0 4px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    font-weight: 700;
}

.preset-item {
    padding: 6px 8px;
    font-size: var(--font-size-sm);
    color: var(--text-color);
    cursor: pointer;
    border-radius: var(--radius-sm);
    border: none;
    background: transparent;
    text-align: left;
    font-family: var(--font-family);
    transition: all var(--transition-fast);
    white-space: nowrap;
}

.preset-item:hover {
    background: var(--button-hover);
}

/* UTILITY */
.hidden {
    display: none !important;
}

.global-drop-hint {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    background: rgba(0, 0, 0, 0.7);
    color: var(--accent-color);
    font-size: 15px;
    font-weight: 600;
    backdrop-filter: blur(8px);
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 300;
}

.global-drop-hint.visible {
    opacity: 1;
}

/* SHORTCUTS MODAL */
.shortcuts-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(5px);
    z-index: 200;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1;
    transition: opacity var(--transition-base);
}

.shortcuts-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

.shortcuts-modal {
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    width: 320px;
    overflow: hidden;
}

.shortcuts-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-lg) var(--spacing-xl);
    border-bottom: 1px solid var(--border-subtle);
}

.shortcuts-header h3 {
    font-size: var(--font-size-md);
    font-weight: 600;
    color: var(--text-color);
}

.close-btn {
    background: none;
    border: none;
    color: var(--text-muted-color);
    font-size: 18px;
    cursor: pointer;
    line-height: 1;
}

.close-btn:hover {
    color: var(--text-color);
}

.shortcuts-list {
    padding: var(--spacing-md) var(--spacing-xl);
}

.shortcut-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.shortcut-row:last-child {
    border-bottom: none;
}

.key-desc {
    font-size: var(--font-size-sm);
    color: var(--text-muted-color);
}

.keys {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: var(--font-size-xs);
    color: var(--text-color);
    font-family: var(--font-mono);
}

kbd {
    display: inline-block;
    padding: 2px 5px;
    border-radius: 4px;
    background: #2a2a2c;
    border: 1px solid #3a3a3c;
    min-width: 18px;
    text-align: center;
}
</file>

<file path="stylesControls.css">
/* FILE: crop/stylesControls.css */

.btn {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    cursor: pointer;
    font-family: "Courier New", monospace;
    font-size: 9px;
    transition: all 0.15s ease-in-out;
}

.btn:hover {
    border-color: #666;
    background: #222;
}

.btn-primary {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.btn-primary:hover {
    background: #ddd;
    border-color: #ddd;
}

.grid-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 9px;
    color: #888;
    cursor: pointer;
}

.grid-toggle input[type="checkbox"] {
    cursor: pointer;
}

.preset-label {
    font-size: 9px;
    color: #888;
}

.preset-dropdown {
    position: relative;
}

.preset-trigger {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 9px;
    cursor: pointer;
    transition: all 0.15s ease-in-out;
    min-width: 120px;
    justify-content: space-between;
}

.preset-trigger:hover {
    border-color: #666;
    background: #222;
}

.preset-trigger.active {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.preset-trigger.pulsing {
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%,
    100% {
        opacity: 1;
    }
    50% {
        opacity: 0.7;
    }
}

.preset-menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 6px;
    display: none;
    flex-direction: column;
    gap: 2px;
    min-width: 200px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 100;
}

.preset-menu.visible {
    display: flex;
}

.preset-group-label {
    font-size: 8px;
    color: #666;
    padding: 6px 8px 2px 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.preset-item {
    padding: 6px 8px;
    font-size: 9px;
    color: #fff;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.1s ease-in-out;
}

.preset-item:hover {
    background: #333;
}

.custom-pixel-inline {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 8px;
}

.custom-aspect-inline {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-left: 4px;
}

.custom-aspect-input {
    width: 40px;
    padding: 2px 3px;
    border-radius: 4px;
    border: 1px solid #444;
    background: #111;
    color: #fff;
    font-size: 9px;
    text-align: center;
    font-family: "Courier New", monospace;
}

.top-right-label {
    font-size: 9px;
    color: #888;
}

.dim-field {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.dim-caption {
    font-size: 7px;
    color: #666;
    text-transform: uppercase;
}

.export-input {
    width: 60px;
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 10px;
    font-family: "Courier New", monospace;
}

.export-input:focus {
    outline: none;
    border-color: #fff;
}

.scale-indicator {
    margin-left: 6px;
    font-size: 8px;
    color: #888;
}

.scale-indicator.hidden {
    display: none;
}

.scale-indicator.ok {
    color: #6ccf6c;
}

.scale-indicator.warn {
    color: #e0c75a;
}

.scale-indicator.bad {
    color: #ff6666;
}

.aspect-btn {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 9px;
    cursor: pointer;
    font-family: "Courier New", monospace;
    transition: all 0.15s ease-in-out;
}

.aspect-btn:hover {
    border-color: #fff;
    background: rgba(255, 255, 255, 0.06);
}

.aspect-btn.active {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.aspect-btn.pulsing {
    animation: pulse 2s ease-in-out infinite;
}
</file>

<file path="view.js">
"use strict";

let activePanel = null;

function initAppView() {
  const app = document.getElementById("app");
  assert(app, "initAppView: missing #app container");
  app.innerHTML = createDropZone();
  bindDropZone();
}

function renderLoadingView() {
  const app = document.getElementById("app");
  assert(app, "renderLoadingView: missing #app container");
  app.innerHTML = `<div class="loading-view">Processing...</div>`;
}

function createDropZone() {
  return `
    <div class="drop-zone" id="drop-zone">
      <input type="file" id="file-input" accept="image/*" class="hidden">
      <div>Drop image here</div>
    </div>
  `;
}

function bindDropZone() {
  const zone = document.getElementById("drop-zone");
  const input = document.getElementById("file-input");
  assert(zone, "bindDropZone: missing drop zone");
  assert(input, "bindDropZone: missing file input");

  zone.onclick = () => input.click();
  input.onchange = (e) => {
    if (e.target.files && e.target.files.length)
      loadImageFile(e.target.files[0]);
  };
  zone.ondragover = (e) => {
    e.preventDefault();
    zone.classList.add("dragging");
  };
  zone.ondragleave = () => zone.classList.remove("dragging");
  zone.ondrop = (e) => {
    e.preventDefault();
    zone.classList.remove("dragging");
    if (e.dataTransfer.files && e.dataTransfer.files.length) {
      loadImageFile(e.dataTransfer.files[0]);
    }
  };
}

function renderCropView() {
  assert(state.image, "renderCropView: no image");
  const app = document.getElementById("app");
  assert(app, "renderCropView: missing #app container");

  app.innerHTML = createCropView();

  bindCropView();
  const viewport = document.getElementById("viewport");
  assert(viewport, "renderCropView: missing viewport");
  const observer = new ResizeObserver(onViewportResize);
  observer.observe(viewport);
  onViewportResize();
}

function createCropView() {
  return `
    <div class="viewport" id="viewport">
      <canvas id="canvas"></canvas>
      <div class="crop-overlay" id="crop-overlay">
        <div class="crop-area" id="crop-area"></div>
        <div class="handle nw" data-handle="nw"></div><div class="handle ne" data-handle="ne"></div>
        <div class="handle sw" data-handle="sw"></div><div class="handle se" data-handle="se"></div>
        <div class="edge n" data-handle="n"></div><div class="edge s" data-handle="s"></div>
        <div class="edge w" data-handle="w"></div><div class="edge e" data-handle="e"></div>
        <canvas id="grid-canvas" class="grid-canvas"></canvas>
      </div>
    </div>
    ${createInfoPills()}
    ${createCornerIcons()}
    ${createPanels()}
    ${createBottomBar()}
    ${createShortcutsOverlay()}
  `;
}

function createInfoPills() {
  return `
    <div class="info-pills">
      <div class="info-pill" id="source-info">‚Äî</div>
      <div class="info-pill" id="crop-info">‚Äî</div>
    </div>
  `;
}

function createCornerIcons() {
  return `
    <button class="corner-icon corner-icon-tl" id="icon-aspect" onclick="togglePanel('aspect')" title="Aspect Ratio">
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
        <rect x="3" y="3" width="14" height="14" rx="2"/>
        <path d="M3 10h14M10 3v14"/>
      </svg>
    </button>
    <button class="corner-icon corner-icon-tr" id="icon-presets" onclick="togglePanel('presets')" title="Presets">
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
        <rect x="3" y="3" width="5" height="5" rx="1"/>
        <rect x="12" y="3" width="5" height="5" rx="1"/>
        <rect x="3" y="12" width="5" height="5" rx="1"/>
        <rect x="12" y="12" width="5" height="5" rx="1"/>
      </svg>
    </button>
    <button class="corner-icon corner-icon-br" id="icon-export" onclick="togglePanel('export')" title="Export">
      <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M6 10l4 4 4-4M10 3v11"/>
        <path d="M3 14v2a2 2 0 002 2h10a2 2 0 002-2v-2"/>
      </svg>
    </button>
  `;
}

function createPanels() {
  return `
    <div class="slide-panel panel-aspect" id="panel-aspect">
      ${createAspectContent()}
    </div>
    <div class="slide-panel panel-presets" id="panel-presets">
      ${createPresetsContent()}
    </div>
    <div class="slide-panel panel-export" id="panel-export">
      ${createExportContent()}
    </div>
  `;
}

function createAspectContent() {
  return `
    <div class="aspect-pills">
      <button class="aspect-pill" data-aspect="0" onclick="setAspectFromButton(0)">Free</button>
      <button class="aspect-pill" data-aspect="1" onclick="setAspectFromButton(1)">1:1</button>
      <button class="aspect-pill" data-aspect="${4 / 3}" onclick="setAspectFromButton(${4 / 3})">4:3</button>
      <button class="aspect-pill" data-aspect="${3 / 2}" onclick="setAspectFromButton(${3 / 2})">3:2</button>
      <button class="aspect-pill" data-aspect="${16 / 9}" onclick="setAspectFromButton(${16 / 9})">16:9</button>
      <button class="aspect-pill" data-aspect="${9 / 16}" onclick="setAspectFromButton(${9 / 16})">9:16</button>
    </div>
  `;
}

function createPresetsContent() {
  return `
    <div style="max-height: 400px; overflow-y: auto;">
      <div class="preset-group-label">Instagram</div>
      <button class="preset-item" onclick="selectPixelPreset('social','IG Square',1080,1080)">Square 1080√ó1080</button>
      <button class="preset-item" onclick="selectPixelPreset('social','IG Portrait',1080,1350)">Portrait 1080√ó1350</button>
      <button class="preset-item" onclick="selectPixelPreset('social','IG Story',1080,1920)">Story 1080√ó1920</button>
      <div class="preset-group-label">Facebook</div>
      <button class="preset-item" onclick="selectPixelPreset('social','FB Link',1200,630)">Link 1200√ó630</button>
      <button class="preset-item" onclick="selectPixelPreset('social','FB Cover',820,312)">Cover 820√ó312</button>
      <div class="preset-group-label">YouTube</div>
      <button class="preset-item" onclick="selectPixelPreset('social','YT Thumb',1280,720)">Thumbnail 1280√ó720</button>
      <button class="preset-item" onclick="selectPixelPreset('social','YT Frame',1920,1080)">Frame 1920√ó1080</button>
      <div class="preset-group-label">Document</div>
      <button class="preset-item" onclick="selectPixelPreset('docs','A4',2480,3508)">A4 2480√ó3508</button>
      <button class="preset-item" onclick="selectPixelPreset('docs','Letter',2550,3300)">Letter 2550√ó3300</button>
    </div>
  `;
}

function createExportContent() {
  return `
    <div class="export-size-inputs">
      <input type="text" id="export-w" class="size-input" inputmode="numeric" oninput="onExportInput('w', this.value)">
      <span class="size-separator">√ó</span>
      <input type="text" id="export-h" class="size-input" inputmode="numeric" oninput="onExportInput('h', this.value)">
    </div>
    <div id="scale-indicator-export" class="scale-indicator" style="margin-bottom: 12px; text-align: center;"></div>
    <button class="export-action" onclick="exportImage()">
      <svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M6 10l4 4 4-4M10 3v11"/>
        <path d="M3 14v2a2 2 0 002 2h10a2 2 0 002-2v-2"/>
      </svg>
      <span>Export</span>
    </button>
  `;
}

function createBottomBar() {
  return `
    <div class="bottom-bar">
      <div class="tool-group">
        <button class="tool-btn" onclick="undo()" title="Undo (Ctrl+Z)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M4.5 7h6a3.5 3.5 0 110 7h-2"/>
            <path d="M7 4.5L4.5 7 7 9.5"/>
          </svg>
        </button>
        <button class="tool-btn" onclick="redo()" title="Redo (Ctrl+Shift+Z / Ctrl+Y)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
             <path d="M11.5 7h-6a3.5 3.5 0 100 7h2"/>
             <path d="M9 4.5L11.5 7 9 9.5"/>
          </svg>
        </button>
      </div>

      <div class="tool-separator"></div>

      <button class="tool-btn" onclick="toggleGrid()" title="Grid (G)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M5.5 2v12M10.5 2v12M2 5.5h12M2 10.5h12"/>
        </svg>
      </button>

      <div class="zoom-group">
        <button class="tool-btn" onclick="zoomToFit()" title="Fit (F)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="10" height="10" rx="1"/>
            <path d="M6 6l4 4M10 6l-4 4"/>
          </svg>
        </button>
        <input type="range" id="zoom-slider" min="0" max="1000" step="1">
        <div id="zoom-indicator">100%</div>
        <button class="tool-btn" onclick="zoomToActual()" title="100% (1)">1:1</button>
      </div>

      <div class="tool-separator"></div>

      <button class="tool-btn" onclick="resetCrop()" title="Reset (R)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M2 8a6 6 0 0112 0M14 8a6 6 0 01-12 0"/>
          <path d="M2 4v4h4M14 12v-4h-4"/>
        </svg>
      </button>

      <button class="tool-btn" onclick="newImage()" title="New (N)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="2" y="2" width="12" height="12" rx="2"/>
          <path d="M8 5v6M5 8h6"/>
        </svg>
      </button>

      <div class="tool-separator"></div>

      <button class="tool-btn" onclick="toggleShortcuts()" title="Shortcuts (?)">
        <span style="font-family: var(--font-mono); font-weight: 700;">?</span>
      </button>
    </div>
  `;
}

function createShortcutsOverlay() {
  return `
    <div id="shortcuts-overlay" class="shortcuts-overlay hidden" onclick="toggleShortcuts()">
      <div class="shortcuts-modal" onclick="event.stopPropagation()">
        <div class="shortcuts-header">
          <h3>Keyboard Shortcuts</h3>
          <button class="close-btn" onclick="toggleShortcuts()">√ó</button>
        </div>
        <div class="shortcuts-list">
          <div class="shortcut-row"><span class="key-desc">Undo</span> <div class="keys"><kbd>Ctrl</kbd> + <kbd>Z</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Redo</span> <div class="keys"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Redo (Alt)</span> <div class="keys"><kbd>Ctrl</kbd> + <kbd>Y</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Toggle Grid</span> <div class="keys"><kbd>G</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Zoom to Fit</span> <div class="keys"><kbd>F</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Zoom 1:1</span> <div class="keys"><kbd>1</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Reset Crop</span> <div class="keys"><kbd>R</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">New Image</span> <div class="keys"><kbd>N</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Export</span> <div class="keys"><kbd>Ctrl</kbd> + <kbd>Enter</kbd></div></div>
          <div class="shortcut-row"><span class="key-desc">Close Panels</span> <div class="keys"><kbd>Esc</kbd></div></div>
        </div>
      </div>
    </div>
  `;
}

function toggleShortcuts() {
  const overlay = document.getElementById("shortcuts-overlay");
  if (overlay) overlay.classList.toggle("hidden");
}

function togglePanel(panelName) {
  const panel = document.getElementById(`panel-${panelName}`);
  const icon = document.getElementById(`icon-${panelName}`);

  if (activePanel === panelName) {
    panel.classList.remove("visible");
    icon.classList.remove("active");
    activePanel = null;
  } else {
    if (activePanel) {
      document
        .getElementById(`panel-${activePanel}`)
        .classList.remove("visible");
      document.getElementById(`icon-${activePanel}`).classList.remove("active");
    }
    panel.classList.add("visible");
    icon.classList.add("active");
    activePanel = panelName;
  }
}

function bindCropView() {
  document
    .querySelectorAll("[data-handle]")
    .forEach((h) => (h.onmousedown = (e) => startDrag(e, h.dataset.handle)));

  const area = document.getElementById("crop-area");
  assert(area, "bindCropView: missing crop area");
  area.onmousedown = (e) => startDrag(e, "move");

  const viewport = document.getElementById("viewport");
  viewport.onwheel = handleWheelZoom;
  viewport.onmousedown = (e) => {
    if (e.target === viewport) startDrag(e, "pan-image");
  };

  document.getElementById("zoom-slider").oninput = handleSliderZoom;
  document.addEventListener("keydown", handleKeyboard);

  syncExportInputsToCrop();
  updateAspectUI();
  updateCropInfoUI();
}

function setAspectFromButton(ratio) {
  if (!state.image) return;
  clearAllSelections();
  if (ratio === 0) {
    setMode(MODE.NONE);
    state.aspectRatio = 0;
  } else {
    setMode(MODE.ASPECT_RATIO);
    state.aspectRatio = ratio;
    applyAspectToCrop(ratio);
  }
  updateAspectUI();
  requestRender();
  scheduleCommit();
  pushHistory("Aspect Change");
}

function handleKeyboard(e) {
  if (e.target.tagName === "INPUT") return;

  const cmd = e.metaKey || e.ctrlKey;

  // Undo / Redo Logic
  if (cmd) {
    if (e.key === "z") {
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
      return;
    }
    if (e.key === "y") {
      e.preventDefault();
      redo();
      return;
    }
  }

  // Shortcuts Overlay
  if (e.key === "?") {
    toggleShortcuts();
    return;
  }

  if (e.key === "g") toggleGrid();
  else if (e.key === "r") resetCrop();
  else if (e.key === "f") zoomToFit();
  else if (e.key === "1") zoomToActual();
  else if (e.key === "n") newImage();
  else if (e.key === "Escape") {
    const shortcuts = document.getElementById("shortcuts-overlay");
    if (shortcuts && !shortcuts.classList.contains("hidden")) {
      toggleShortcuts();
    } else if (activePanel) {
      togglePanel(activePanel);
    }
  } else if (cmd && e.key === "Enter") exportImage();
}

function onViewportResize() {
  if (!state.image) return;
  if (state.drag || state.committing) return;
  recalculateLayout();
  requestRender();
}

function handleWheelZoom(e) {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -1 : 1;
  const zoomFactor = 1.1;
  const newZoom = state.zoom * (delta > 0 ? zoomFactor : 1 / zoomFactor);
  const rect = e.currentTarget.getBoundingClientRect();
  const focalPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  setZoom(newZoom, focalPoint);
}

function handleSliderZoom(e) {
  const sliderValue = e.target.value / 1000;
  const logMin = Math.log(MIN_ZOOM);
  const logMax = Math.log(MAX_ZOOM);
  const newZoom = Math.exp(logMin + (logMax - logMin) * sliderValue);
  const focalPoint = { x: state.viewport.w / 2, y: state.viewport.h / 2 };
  setZoom(newZoom, focalPoint);
}

function updateCropInfoUI() {
  const srcInfo = document.getElementById("source-info");
  const cropInfo = document.getElementById("crop-info");

  if (!state.image) return;

  const srcW = state.fullImage?.naturalWidth || state.image.naturalWidth;
  const srcH = state.fullImage?.naturalHeight || state.image.naturalHeight;
  if (srcInfo) srcInfo.textContent = `${srcW}√ó${srcH}`;

  const { w, h } = state.crop;
  const actualW = Math.round(w);
  const actualH = Math.round(h);
  if (cropInfo) cropInfo.textContent = `${actualW}√ó${actualH}`;

  updateScaleIndicator();
}

function updateScaleIndicator() {
  const scaleExport = document.getElementById("scale-indicator-export");

  const { w, h } = state.crop;
  const actualW = Math.round(w);
  const actualH = Math.round(h);

  const exportW =
    parseInt(document.getElementById("export-w")?.value) || actualW;
  const exportH =
    parseInt(document.getElementById("export-h")?.value) || actualH;

  const scaleX = exportW / actualW;
  const scaleY = exportH / actualH;
  const scale = Math.min(scaleX, scaleY);

  let text, className;
  if (Math.abs(scale - 1) < 0.1) {
    text = "1:1";
    className = "ok";
  } else if (scale < 1) {
    text = `‚Üì${Math.round((1 - scale) * 100)}%`;
    className = "ok";
  } else if (scale <= 1.5) {
    text = `‚Üë${Math.round((scale - 1) * 100)}%`;
    className = "ok";
  } else if (scale <= 2) {
    text = `‚Üë${Math.round((scale - 1) * 100)}%`;
    className = "warn";
  } else {
    text = `‚Üë${Math.round((scale - 1) * 100)}%`;
    className = "bad";
  }

  if (scaleExport) {
    scaleExport.textContent = text;
    scaleExport.className = `scale-indicator ${className}`;
  }
}

function updateAspectUI() {
  document.querySelectorAll(".aspect-pill[data-aspect]").forEach((btn) => {
    const ratio = parseFloat(btn.dataset.aspect);
    const isActive =
      (state.mode === MODE.NONE && ratio === 0) ||
      (state.mode === MODE.ASPECT_RATIO &&
        Math.abs(state.aspectRatio - ratio) < EPSILON);
    btn.classList.toggle("active", isActive);
  });
  updatePresetTriggers();
}

function renderFrame() {
  if (!state.image) return;
  const canvas = document.getElementById("canvas");
  const overlay = document.getElementById("crop-overlay");
  if (!canvas || !overlay) return;

  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  const img = state.image;
  if (
    canvas.width !== img.naturalWidth ||
    canvas.height !== img.naturalHeight
  ) {
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);
  }

  const { tx, ty } = state.imageTransform;
  const { x, y, w, h } = state.crop;
  const currentScale = state.baseScale * state.zoom;

  const screenPixelsPerImagePixel = currentScale / state.previewScale;
  canvas.style.imageRendering =
    screenPixelsPerImagePixel > 2.5 ? "pixelated" : "auto";

  canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${currentScale})`;
  canvas.className = state.committing ? "canvas-committing" : "";
  overlay.className = state.committing
    ? "crop-overlay committing"
    : state.drag
      ? "crop-overlay dragging"
      : "crop-overlay";

  const previewX = x / state.previewScale;
  const previewY = y / state.previewScale;
  const previewW = w / state.previewScale;
  const previewH = h / state.previewScale;
  const cropLeft = tx + previewX * currentScale;
  const cropTop = ty + previewY * currentScale;
  const cropW = previewW * currentScale;
  const cropH = previewH * currentScale;

  overlay.style.left = `${cropLeft}px`;
  overlay.style.top = `${cropTop}px`;
  overlay.style.width = `${cropW}px`;
  overlay.style.height = `${cropH}px`;

  const gridCanvas = document.getElementById("grid-canvas");
  if (gridCanvas) renderGrid(gridCanvas, cropW, cropH);

  updateCropInfoUI();
  updatePresetTriggers();
  syncExportInputsToCrop();
  updateZoomUI();
}

function updateZoomUI() {
  const indicator = document.getElementById("zoom-indicator");
  const slider = document.getElementById("zoom-slider");
  if (!indicator || !slider) return;

  const screenPixelsPerImagePixel =
    (state.baseScale * state.zoom) / state.previewScale;
  indicator.textContent = `${(screenPixelsPerImagePixel * 100).toFixed(0)}%`;

  const logMin = Math.log(MIN_ZOOM);
  const logMax = Math.log(MAX_ZOOM);
  const currentVal = Math.log(state.zoom);
  const sliderPos = ((currentVal - logMin) / (logMax - logMin)) * 1000;
  if (document.activeElement !== slider) slider.value = sliderPos;
}

function renderGrid(gridCanvas, cropW, cropH) {
  if (!state.showGrid) {
    gridCanvas.style.display = "none";
    return;
  }
  gridCanvas.style.display = "block";
  if (gridCanvas.width !== cropW || gridCanvas.height !== cropH) {
    gridCanvas.width = cropW;
    gridCanvas.height = cropH;
  }
  const gctx = gridCanvas.getContext("2d");
  if (!gctx) return;
  gctx.clearRect(0, 0, cropW, cropH);
  gctx.strokeStyle = "rgba(255,255,255,0.25)";
  gctx.lineWidth = 1;
  const x1 = cropW / 3,
    x2 = (cropW * 2) / 3,
    y1 = cropH / 3,
    y2 = (cropH * 2) / 3;
  gctx.beginPath();
  gctx.moveTo(x1, 0);
  gctx.lineTo(x1, cropH);
  gctx.moveTo(x2, 0);
  gctx.lineTo(x2, cropH);
  gctx.moveTo(0, y1);
  gctx.lineTo(cropW, y1);
  gctx.moveTo(0, y2);
  gctx.lineTo(cropW, y2);
  gctx.stroke();
}

function toggleGrid() {
  state.showGrid = !state.showGrid;
  requestRender();
}
</file>

<file path="viewAspect.js">
"use strict";

function setAspectFromBar(ratio) {
  assert(typeof ratio === "number", "setAspectFromBar: ratio must be number");

  if (!state.image && ratio !== 0) {
    console.warn("setAspectFromBar: no image loaded");
    return;
  }

  clearAllSelections();

  if (!ratio || ratio <= 0) {
    setMode(MODE.NONE);
    state.aspectRatio = 0;
  } else {
    validateAspectRatio(ratio);
    setMode(MODE.ASPECT_RATIO);
    state.aspectRatio = ratio;
    applyAspectToCrop(ratio);
  }

  requestRender();
  scheduleCommit();

  // --- HISTORY PUSH ---
  pushHistory("Aspect Change");
}

function createAspectButtons() {
  const ratios = [
    { label: "Free", value: 0 },
    { label: "1:1", value: 1 },
    { label: "4:3", value: 4 / 3 },
    { label: "3:2", value: 3 / 2 },
    { label: "5:4", value: 5 / 4 },
    { label: "16:9", value: 16 / 9 },
    { label: "9:16", value: 9 / 16 },
    { label: "21:9", value: 21 / 9 },
  ];

  const current = state.mode === MODE.ASPECT_RATIO ? state.aspectRatio : 0;

  return ratios
    .map((r) => {
      const isActive =
        (r.value === 0 && state.mode === MODE.NONE) ||
        (state.mode === MODE.ASPECT_RATIO &&
          r.value > 0 &&
          Math.abs(current - r.value) < EPSILON);
      const cls = isActive ? "aspect-btn active" : "aspect-btn";
      return `<button class="${cls}" onclick="setAspectFromBar(${r.value})">${r.label}</button>`;
    })
    .join("");
}

function createCustomAspectControl() {
  const isWaiting = state.customAspectActive;
  const hasCustom =
    state.mode === MODE.ASPECT_RATIO &&
    !state.customAspectActive &&
    state.customAspectLabel !== "Custom";

  const label = hasCustom ? state.customAspectLabel : "Custom";

  const btnClsParts = ["aspect-btn"];
  if (state.mode === MODE.ASPECT_RATIO && (isWaiting || hasCustom)) {
    btnClsParts.push("active");
  }
  if (isWaiting) {
    btnClsParts.push("pulsing");
  }
  const btnCls = btnClsParts.join(" ");

  const inputs = isWaiting
    ? `
      <input id="custom-aspect-w" class="custom-aspect-input" type="number" min="1"
             placeholder="W" value="${state.customAspectW || ""}">
      <span>:</span>
      <input id="custom-aspect-h" class="custom-aspect-input" type="number" min="1"
             placeholder="H" value="${state.customAspectH || ""}">
      <button class="btn" onclick="applyCustomAspectInline()">‚úî Apply</button>
    `
    : "";

  return `
    <div class="custom-aspect-inline">
      <button class="${btnCls}" onclick="toggleCustomAspectActive()">${label}</button>
      ${inputs}
    </div>
  `;
}

function toggleCustomAspectActive() {
  if (!state.customAspectActive) {
    clearAllSelections();
    state.customAspectActive = true;
    setMode(MODE.ASPECT_RATIO);
  } else {
    state.customAspectActive = false;
    setMode(MODE.NONE);
    state.aspectRatio = 0;
  }
  requestRender();
}

function applyCustomAspectInline() {
  if (!state.image) {
    console.warn("applyCustomAspectInline: no image loaded");
    return;
  }

  const wEl = document.getElementById("custom-aspect-w");
  const hEl = document.getElementById("custom-aspect-h");

  if (!wEl || !hEl) {
    console.error("applyCustomAspectInline: input elements not found");
    return;
  }

  const w = parseInt(wEl.value, 10);
  const h = parseInt(hEl.value, 10);

  if (!(w > 0 && h > 0)) {
    console.warn("applyCustomAspectInline: invalid dimensions");
    return;
  }

  const reduced = reduceRatio(w, h);
  if (!(reduced.w > 0 && reduced.h > 0)) {
    console.error("applyCustomAspectInline: reduceRatio failed");
    return;
  }

  const ratio = reduced.w / reduced.h;
  validateAspectRatio(ratio);

  clearAllSelections();
  setMode(MODE.ASPECT_RATIO);
  state.customAspectActive = false;
  state.aspectRatio = ratio;
  state.customAspectW = String(reduced.w);
  state.customAspectH = String(reduced.h);
  state.customAspectLabel = `Custom ${reduced.w}:${reduced.h}`;

  applyAspectToCrop(ratio);
  requestRender();
  scheduleCommit();

  // --- HISTORY PUSH ---
  pushHistory("Custom Aspect");
}
</file>

<file path="viewPresets.js">
"use strict";

function createTopCenterPresets() {
  return `
    <div class="top-center" onclick="event.stopPropagation()">
      <div class="preset-label">Presets</div>

      <div class="preset-dropdown">
        <div
          id="preset-social-trigger"
          class="preset-trigger btn"
          onclick="togglePresetMenu(event, 'social')">
          <span>${state.presetLabels.social}</span><span>‚ñæ</span>
        </div>
        <div id="preset-social-menu" class="preset-menu">
          ${createSocialPresets()}
        </div>
      </div>

      <div class="preset-dropdown">
        <div
          id="preset-docs-trigger"
          class="preset-trigger btn"
          onclick="togglePresetMenu(event, 'docs')">
          <span>${state.presetLabels.docs}</span><span>‚ñæ</span>
        </div>
        <div id="preset-docs-menu" class="preset-menu">
          ${createDocsPresets()}
        </div>
      </div>

      <div class="preset-dropdown">
        <div
          id="preset-custom-trigger"
          class="preset-trigger btn ${state.customPixelActive ? "active pulsing" : ""}"
          onclick="toggleCustomPixelActive(event)">
          <span>${state.presetLabels["custom-pixel"]}</span><span>‚ñæ</span>
        </div>
        <div id="preset-custom-pixel-menu"
             class="preset-menu ${state.customPixelActive ? "visible" : ""}">
          ${createCustomPixelControl()}
        </div>
      </div>
    </div>
  `;
}

function createSocialPresets() {
  return `
    <div class="preset-group-label">Instagram</div>
    <div class="preset-item" onclick="selectPixelPreset('social','IG Square 1080√ó1080',1080,1080)">Square 1:1 1080√ó1080</div>
    <div class="preset-item" onclick="selectPixelPreset('social','IG Portrait 1080√ó1350',1080,1350)">Portrait 4:5 1080√ó1350</div>
    <div class="preset-item" onclick="selectPixelPreset('social','IG Landscape 1080√ó566',1080,566)">Landscape 1080√ó566</div>
    <div class="preset-item" onclick="selectPixelPreset('social','IG Story 1080√ó1920',1080,1920)">Story/Reel 1080√ó1920</div>

    <div class="preset-group-label">Facebook</div>
    <div class="preset-item" onclick="selectPixelPreset('social','FB Link 1200√ó630',1200,630)">Link 1200√ó630</div>
    <div class="preset-item" onclick="selectPixelPreset('social','FB Post 1080√ó1080',1080,1080)">Post 1080√ó1080</div>
    <div class="preset-item" onclick="selectPixelPreset('social','FB Cover 820√ó312',820,312)">Cover 820√ó312</div>

    <div class="preset-group-label">X / Twitter</div>
    <div class="preset-item" onclick="selectPixelPreset('social','X Post 1600√ó900',1600,900)">Post 1600√ó900</div>
    <div class="preset-item" onclick="selectPixelPreset('social','X Header 1500√ó500',1500,500)">Header 1500√ó500</div>

    <div class="preset-group-label">YouTube</div>
    <div class="preset-item" onclick="selectPixelPreset('social','YT Thumb 1280√ó720',1280,720)">Thumbnail 1280√ó720</div>
    <div class="preset-item" onclick="selectPixelPreset('social','YT Frame 1920√ó1080',1920,1080)">Frame 1920√ó1080</div>
  `;
}

function createDocsPresets() {
  return `
    <div class="preset-group-label">Print @300dpi</div>
    <div class="preset-item" onclick="selectPixelPreset('docs','A4 2480√ó3508',2480,3508)">A4 2480√ó3508</div>
    <div class="preset-item" onclick="selectPixelPreset('docs','Letter 2550√ó3300',2550,3300)">Letter 2550√ó3300</div>
    <div class="preset-item" onclick="selectPixelPreset('docs','A5 1748√ó2480',1748,2480)">A5 1748√ó2480</div>
  `;
}

function createCustomPixelControl() {
  return `
    <div class="preset-group-label">Custom Output Size</div>
    <div class="custom-pixel-inline">
      <input id="custom-pixel-w" type="number" min="1" placeholder="W"
             class="custom-aspect-input"
             value="${state.customPixelW || ""}">
      <span>√ó</span>
      <input id="custom-pixel-h" type="number" min="1" placeholder="H"
             class="custom-aspect-input"
             value="${state.customPixelH || ""}">
      <button class="btn" onclick="applyCustomPixelPreset()">‚úî Apply</button>
    </div>
  `;
}

function togglePresetMenu(ev, key) {
  assert(typeof key === "string", "togglePresetMenu: key must be string");
  ev.stopPropagation();
  const menu = document.getElementById(`preset-${key}-menu`);
  if (!menu) return;
  const visible = menu.classList.contains("visible");
  closeAllPresetMenus();
  if (!visible) menu.classList.add("visible");
}

function toggleCustomPixelActive(ev) {
  ev.stopPropagation();
  closeAllPresetMenus();
  state.customPixelActive = !state.customPixelActive;
  if (!state.customPixelActive) {
    const menu = document.getElementById("preset-custom-pixel-menu");
    if (menu) menu.classList.remove("visible");
  }
  requestRender();
}

function closeAllPresetMenus() {
  document
    .querySelectorAll(".preset-menu.visible")
    .forEach((m) => m.classList.remove("visible"));
}

function selectPixelPreset(key, label, w, h) {
  if (!state.image) return;
  assert(typeof key === "string", "selectPixelPreset: key must be string");
  assert(typeof label === "string", "selectPixelPreset: label must be string");
  validatePixelDimension(w);
  validatePixelDimension(h);

  closeAllPresetMenus();
  clearAllSelections();
  setMode(MODE.PIXEL_PRESET);
  markPresetActive(key, label);

  const ratio = w / h;
  validateAspectRatio(ratio);
  state.aspectRatio = ratio;
  applyAspectToCrop(ratio);

  state.exportW = String(w);
  state.exportH = String(h);

  requestRender();
  scheduleCommit();

  // --- HISTORY PUSH ---
  pushHistory(`Preset: ${label}`);
}

function applyCustomPixelPreset() {
  if (!state.image) return;
  const wEl = document.getElementById("custom-pixel-w");
  const hEl = document.getElementById("custom-pixel-h");
  if (!wEl || !hEl) return;
  const w = parseInt(wEl.value, 10);
  const h = parseInt(hEl.value, 10);
  if (!(w > 0 && h > 0)) return;

  validatePixelDimension(w);
  validatePixelDimension(h);

  closeAllPresetMenus();
  state.customPixelActive = false;

  clearAllSelections();
  setMode(MODE.CUSTOM_PIXEL);
  state.customPixelW = String(w);
  state.customPixelH = String(h);
  markPresetActive("custom-pixel", `Custom ${w}√ó${h}`);

  state.exportW = String(w);
  state.exportH = String(h);

  const ratio = w / h;
  validateAspectRatio(ratio);
  state.aspectRatio = ratio;
  applyAspectToCrop(ratio);

  requestRender();
  scheduleCommit();

  // --- HISTORY PUSH ---
  pushHistory(`Custom Pixel: ${w}x${h}`);
}

function updatePresetTriggers() {
  const map = {
    social: "preset-social-trigger",
    docs: "preset-docs-trigger",
    "custom-pixel": "preset-custom-trigger",
  };
  Object.entries(map).forEach(([key, id]) => {
    const trigger = document.getElementById(id);
    if (!trigger) return;
    const span = trigger.querySelector("span");
    if (span) span.textContent = state.presetLabels[key];
    if (state.activePresetKey === key) trigger.classList.add("active");
    else trigger.classList.remove("active");
  });

  const customMenu = document.getElementById("preset-custom-pixel-menu");
  if (customMenu) {
    if (state.customPixelActive) customMenu.classList.add("visible");
    else customMenu.classList.remove("visible");
  }
}
</file>


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
END CODEBASE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WARDEN CONSTRAINTS:
‚ñ° Files < 2000 tokens
‚ñ° Complexity ‚â§ 10
‚ñ° Nesting ‚â§ 4
‚ñ° Args ‚â§ 5
‚ñ° No .unwrap()
‚ñ° Use <delivery> + <file> tags
