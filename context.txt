<file path=".gitignore">
node_modules
dist
.DS_Store
*.local</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Spencer Nunamaker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# crop — lilapps production asset prep tool

A tiny, fast, professional-grade browser tool for turning any image into production-ready assets.

No sign-ups. No ads. No bullshit. Just drop, frame, export.

Born from a real workflow: as marketers, designers, and devs, we constantly pull images from “Location A” (vendor sites, Google, screenshots, internal decks) and need them adapted for “Location B” (website hero, email header, slider, blog card, social thumb, etc.). Firing up heavy design software for these small but frequent tasks is a massive, repeating tax.

`crop` exists to erase that tax.

You are already in the browser. You drag or paste the image. You set or pick the frame. You get exactly the sizes you need. Fast, precise, and pleasant.

This document outlines:
- Current behavior and priorities
- UX and interaction principles
- Vision: evolving from “crop tool” into the world’s best browser-native production asset prep tool
- Future capabilities (artboards, variants, dev/URL integration, etc.)

All while remaining a small, focused, “lilapps”-style product.

---

## Core Principles

1. Instant
   - Loads fast.
   - Drag-and-drop or paste to start.
   - No accounts, no onboarding wall, no clutter.

2. In-browser and trustworthy
   - All processing client-side.
   - No image uploads to a server.
   - No tracking garbage.
   - Safe for work assets and client materials.

3. Single-screen, single-purpose
   - One focused workspace.
   - No multi-page project system.
   - No trying to be Canva, Figma, or Photoshop.

4. Production-minded
   - Targeted at real, recurring jobs:
     - Website heroes, cards, sliders
     - Social posts and thumbnails
     - Email headers and imagery
     - Presentation and doc assets
   - Defaults and presets are practical, not ornamental.

5. Tiny, perfect, extensible
   - Minimal codebase.
   - Carefully chosen features.
   - Everything added must:
     - Reduce friction.
     - Increase reliability.
     - Stay understandable at a glance.

---

## Current Feature Set

These features exist or are in active development based on the current implementation:

- Global drag-and-drop:
  - Drop an image anywhere to start.
  - If an image is already loaded, drop anywhere to replace it.
  - Clear overlay hint: “Drop image to start” / “Drop image to replace.”

- Core cropping:
  - Full-viewport canvas.
  - Draggable crop area.
  - Corner handles and edge handles for resizing.
  - Minimum crop size enforced.
  - Crop constrained to image bounds.

- Aspect ratios:
  - Quick-select buttons:
    - Free
    - 1:1, 4:3, 3:2, 5:4, 16:9, 9:16, 21:9
  - Custom aspect ratio:
    - Inline input (`W:H`) reduced to simplest form.
    - Applies immediately and locks resizing to that ratio.

- Presets:
  - Social presets (examples):
    - Instagram square, portrait, story
    - Facebook posts and covers
    - X / Twitter posts and headers
    - YouTube thumbnails and frames
  - Document/print presets:
    - A4, Letter, etc. at sensible resolutions.
  - Presets apply both:
    - Crop aspect ratio.
    - Suggested export size.

- Export controls:
  - Numeric width/height fields.
  - Export aligned with current crop and/or active preset.
  - Auto-adjust dimensions to maintain locked aspect when relevant.
  - Export via canvas to a downloadable file.
  - Sensible default filenames:
    - Includes reduced aspect, size, timestamp.

- Smart viewport behavior:
  - Image auto-fits into viewport with margins.
  - When crop changes, the image recenters smoothly around the crop (commit animation).
  - ResizeObserver-driven layout updates.

- State handling:
  - Internal modes:
    - Free
    - Aspect-locked
    - Pixel preset
    - Custom pixel
  - Assertions, clamping, and validation throughout for robust behavior.

- Grid overlay:
  - Rule-of-thirds guide rendered inside the crop.
  - Toggleable.

These pieces already form a serious, high-quality cropping experience.

---

## Immediate UX Enhancements (Planned)

All planned enhancements preserve the simplicity of the UI while making the behavior feel “obvious” to non-technical users.

1. Mode simplification (user-facing)
   - Internally keep modes. Externally present:
     - Free
     - Locked ratio (via aspect buttons)
     - Preset size (via dropdowns)
   - Users never need to think in terms of “modes”; they just:
     - Select a ratio → crop locks.
     - Select a preset → frame + export size align.
     - Manually override → gracefully fall back to “Custom” or “Free” as appropriate.

2. Drag-and-drop polish
   - Ensure consistent behavior:
     - Drop anywhere = load (if empty) or replace (if existing).
   - Maintain relative crop where sensible when replacing images.
   - Clear, minimal overlays and hints.

3. Legibility and ergonomics
   - Slightly larger control typography.
   - Larger hit areas on handles and edges.
   - Subtle background refinement (dark, but not harsh) to focus the eye on content.

4. Undo / redo
   - Lightweight history for:
     - Crop changes
     - Aspect/preset changes
     - Export size adjustments
   - Standard shortcuts:
     - Ctrl/Cmd+Z, Ctrl/Cmd+Shift+Z.

---

## Vision: From Crop Tool to Production Asset Prep Tool

`crop` is evolving into:

“The world’s best browser-native production asset prep tool for people who ship things online.”

Designed for:
- Marketers who need many formats from one idea.
- Social/content teams creating consistent visuals.
- Web devs and designers enforcing image standards.
- Indie founders and studios preparing launch and campaign assets.

Key: this remains a small, single-purpose lilapp. No bloat. Just a more powerful definition of “prep.”

---

## Strategic Feature Pillars

### 1. Artboard / Frame Mode

The foundational concept for everything else.

- Lock a frame:
  - Choose a preset or custom size → that becomes the fixed output frame (artboard).
- Move image, not frame:
  - Pan, zoom, rotate the underlying image within the locked frame.
- Always export at frame size:
  - Guarantees exact, repeatable dimensions.

Why:
- Matches how real-world placements work (hero slots, ad units, thumbnails).
- Becomes the base for responsive/variant logic.

Status:
- High priority. This becomes the primary interaction model when presets are used.

---

### 2. Variants: Design Once, Export Many (Auto-Variant System)

This is the flagship innovation.

Problem:
- The same visual concept must exist in many sizes:
  - 16:9 cover, 1:1 thumb, 9:16 story, email header, etc.
- Today, that work is repetitive and manual.

Goal:
- Let users define a single master composition and generate multiple size variants with minimal extra work.
- Stay deterministic and understandable (no black-box “AI auto layouts”).

Concept:
- Master layout:
  - User designs one frame (artboard) with:
    - Background image (cropped/positioned).
    - Future: logo, simple text, or extra shapes (when layers arrive).
- Variant frames:
  - User selects a set of target sizes (e.g., “Social pack,” “Ad set”).
  - Each variant:
    - Shares the master composition via simple rules:
      - How backgrounds scale.
      - How focal points align.
      - How overlays pin to corners/edges.
    - Can be gently tweaked per-variant when needed.

Principles:
- Small, predictable rule set:
  - Pinning (e.g., top-left, centered).
  - Scaling:
    - Fixed-size or relative to frame.
  - Optional overrides.
- Visual clarity:
  - Show all variants as a list or small strip.
  - Quick flip between them.
  - “Export all” in one click.

This system:
- Turns `crop` into a serious time-saver for campaigns and launches.
- Stays aligned with the lilapps ethos by using a minimal, carefully designed rule model instead of a heavy layout engine.

---

### 3. High-Confidence Export (Format and Quality Intelligence)

`crop` should quietly “do the right thing” with file formats.

Planned:
- Export formats:
  - PNG
  - JPEG
  - WebP
- Simple quality presets:
  - Crisp (high quality)
  - Balanced (recommended)
  - Tiny (for email/low-bandwidth)
- Intention-based labeling:
  - “Optimized for web”
  - “Optimized for email”
  - “Preserve sharp edges (logos/UI)”
- Under the hood:
  - sRGB normalization.
  - Smart defaults for photos vs. graphics.
  - Respect for transparency when needed.

Outcome:
- Users trust that exports are:
  - The right size.
  - The right format.
  - Reasonably optimized without manual tuning.

---

### 4. Micro Adjustments (Prep-Grade, Not Filter-Grade)

Goal:
- Only adjustments that serve readability and layout.

Planned:
- Subtle, controlled sliders:
  - Brightness
  - Contrast
  - Saturation
  - Optional: blur (e.g., for background plates)
- Designed for:
  - Making text-over-image placements cleaner.
  - Making assets consistent, not “stylized.”

No filter gimmicks. Strictly production utility.

---

### 5. Layers and Simple Compositing (Future)

Acknowledged future direction (not immediate):

- Support multiple images/elements:
  - Background image(s)
  - Logos
  - Decorative shapes or panels
  - Eventually minimal text blocks
- Presented as:
  - A very small, clear layer stack.
- Integrated with:
  - Artboard mode.
  - Variant rules (symbols-style behavior).

This will be tackled cautiously to preserve simplicity.

---

### 6. Text (Back Burner, By Design)

Text is powerful but complex.

Position:
- Will not be rushed.
- When implemented:
  - Minimal, structured:
    - Headline blocks, small labels.
  - Treated as layout elements, not a generic rich text editor.
- Must integrate cleanly with variants and artboards.

Until then:
- Focus is on framing and exporting great backplates and image-led assets.

---

### 7. Dev and URL-Based Control (Tooling for Teams)

`crop` should be delightful for non-technical users and quietly powerful for devs and system thinkers.

Planned capabilities:
- URL-driven presets:
  - Examples:
    - `croptool.app/968x600-MyHero`
    - `croptool.app/1280x720-YouTubeThumb`
  - On load:
    - Preconfigures frame size, labels, and behavior.
- Optional query parameters (introduced carefully):
  - Format (`fmt=jpg`)
  - Quality preset (`q=balanced`)
  - Grid visibility
  - Preset packs (`preset=social-basic`)
  - Variant sets (`variant=all`)
- Local favorites:
  - Save a few custom presets in-browser:
    - Names, sizes, aspect ratios.

Result:
- Teams can:
  - Standardize image prep with shareable links.
  - Embed “Edit in crop” links in docs and repos.
- Power users get an automation surface without affecting normal users.

---

## Non-Goals

To protect the product’s clarity and quality, `crop` is explicitly NOT:

- A full design suite
- A template marketplace
- A collaboration platform
- A complex video editor (video support, if any, will be extremely focused and considered separately)
- A bloated, growth-hacked SaaS product

If a feature does not:
- Make asset prep faster,
- Improve consistency,
- Or increase confidence in the output,

it does not belong.

---

## Summary

`crop` started as “I just want a better way to crop.” It is evolving into:

- A polished, trustworthy, minimal tool for:
  - Framing,
  - Resizing,
  - Lightly adjusting,
  - And intelligently exporting

marketing and product visuals at the speed of real work.

It stays small. It stays sharp. It feels like cheating compared to firing up a full design suite for simple, constant, production tasks.
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Image Crop Tool</title>
        <link rel="stylesheet" href="./styles.css" />
        <link rel="stylesheet" href="./stylesControls.css" />
    </head>
    <body>
        <div id="app"></div>
        <script type="module" src="/src/main.ts"></script>
    </body>
</html></file>

<file path="next-steps-notes.md">
<ERROR READING FILE: No such file or directory (os error 2)>
</file>

<file path="package.json">
{
  "name": "whatacrop",
  "version": "2.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "biome check src/"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.0",
    "typescript": "^5.6.0",
    "vite": "^5.4.0"
  }
}</file>

<file path="src/constants.ts">
export const MIN_CROP = 20;
export const COMMIT_DELAY = 350;
export const CENTER_MARGIN = 0.15;
export const TRANSITION_MS = 500;
export const MAX_CANVAS_DIM = 16384;
export const EPSILON = 0.001;
export const MAX_ASPECT_VALUE = 100;
export const MAX_PIXEL_DIM = 50000;
export const PREVIEW_MAX_DIM = 4096;
export const MIN_ZOOM = 0.1;
export const MAX_ZOOM = 32.0;

export enum Mode {
  NONE = "none",
  ASPECT_RATIO = "aspect-ratio",
  PIXEL_PRESET = "pixel-preset",
  CUSTOM_PIXEL = "custom-pixel",
}</file>

<file path="src/logic/export.ts">
import { state, validateCrop } from '../state';
import { MAX_CANVAS_DIM } from '../constants';
import { clamp, assert, reduceRatio } from '../utils';

export function generateFilename(w: number, h: number): string {
  const ratio = reduceRatio(w, h);
  return `crop_${ratio.w}-${ratio.h}_${w}x${h}_${Date.now()}.png`;
}

export function createExportBlob(w: number, h: number): Promise<Blob | null> {
  return new Promise((resolve) => {
    if (!state.image) return resolve(null);
    validateCrop(state.crop);

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    if (!ctx) return resolve(null);

    const fullImg = state.fullImage || state.image;
    const { x, y, w: sw, h: sh } = state.crop;
    
    const sx = clamp(x, 0, fullImg.naturalWidth - sw);
    const sy = clamp(y, 0, fullImg.naturalHeight - sh);

    ctx.drawImage(fullImg, sx, sy, sw, sh, 0, 0, w, h);
    canvas.toBlob(blob => resolve(blob), "image/png", 1.0);
  });
}</file>

<file path="src/logic/file-load.ts">
import { state, validateCrop, clearAllSelections } from '../state';
import { MAX_CANVAS_DIM, PREVIEW_MAX_DIM } from '../constants';
import { Result, Ok, Err } from '../types';
import { recalculateLayout } from './transform';
import { renderLoadingView, renderCropView } from '../ui/init';
import { requestRender } from '../ui/render';

export function loadImageFile(file: File): void {
  if (!file) return;
  renderLoadingView();
  
  const reader = new FileReader();
  reader.onload = (e) => {
    if (typeof e.target?.result !== 'string') return;
    const img = new Image();
    img.onload = () => handleImageLoaded(img);
    img.onerror = () => alert("Failed to load image");
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

function handleImageLoaded(img: HTMLImageElement): void {
  const valid = validateImageDimensions(img);
  if (!valid.ok) {
    alert(valid.error);
    return;
  }
  
  const fullImage = img;
  const maxDim = Math.max(fullImage.naturalWidth, fullImage.naturalHeight);
  
  if (maxDim > PREVIEW_MAX_DIM) {
    createPreview(fullImage).then(({ preview, scale }) => {
      finalizeLoad(fullImage, preview, scale);
    });
  } else {
    finalizeLoad(fullImage, fullImage, 1);
  }
}

function validateImageDimensions(img: HTMLImageElement): Result<boolean, string> {
  if (img.naturalWidth <= 0 || img.naturalHeight <= 0) return Err("Invalid dimensions");
  if (img.naturalWidth > MAX_CANVAS_DIM || img.naturalHeight > MAX_CANVAS_DIM) return Err("Image too large");
  return Ok(true);
}

function createPreview(full: HTMLImageElement): Promise<{ preview: HTMLImageElement; scale: number }> {
  return new Promise((resolve) => {
    const scale = PREVIEW_MAX_DIM / Math.max(full.naturalWidth, full.naturalHeight);
    const w = Math.round(full.naturalWidth * scale);
    const h = Math.round(full.naturalHeight * scale);
    
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    if (ctx) ctx.drawImage(full, 0, 0, w, h);
    
    const preview = new Image();
    preview.onload = () => resolve({ preview, scale: full.naturalWidth / preview.naturalWidth });
    preview.src = canvas.toDataURL();
  });
}

function finalizeLoad(full: HTMLImageElement, preview: HTMLImageElement, scale: number): void {
  state.fullImage = full;
  state.image = preview;
  state.previewScale = scale;
  
  resetCropToFull(full);
  clearAllSelections();
  state.committing = false;
  
  renderCropView();
  requestAnimationFrame(() => {
    // CRITICAL FIX: Ensure viewport is measured before first fit
    recalculateLayout(); 
    requestRender();
  });
}

export function resetCropToFull(img: HTMLImageElement): void {
  state.crop = { x: 0, y: 0, w: img.naturalWidth, h: img.naturalHeight };
  validateCrop(state.crop);
}</file>

<file path="src/logic/history.ts">
import { state, Snapshot, validateCrop } from '../state';
import { requestRender } from '../ui/render';
import { updatePresetTriggers } from '../ui/presets';
import { syncExportInputsToCrop } from '../ui/export';
import { EPSILON } from '../constants';

const MAX_HISTORY = 50;

export function initHistory(): void {
  state.history = [];
  state.historyIndex = -1;
}

export function pushHistory(label: string): void {
  // If we are in the middle of the stack, chop off the future
  if (state.historyIndex < state.history.length - 1) {
    state.history = state.history.slice(0, state.historyIndex + 1);
  }

  const snapshot = createSnapshot();

  // Deduplication
  if (state.historyIndex >= 0) {
    const current = state.history[state.historyIndex];
    if (areSnapshotsEqual(current, snapshot)) return;
  }

  state.history.push(snapshot);

  if (state.history.length > MAX_HISTORY) {
    state.history.shift();
  } else {
    state.historyIndex++;
  }
  
  console.log(`[History] Pushed: ${label}`);
}

export function undo(): void {
  if (state.historyIndex <= 0) return;

  state.historyIndex--;
  const prev = state.history[state.historyIndex];
  restoreSnapshot(prev);
  requestRender();
}

export function redo(): void {
  if (state.historyIndex >= state.history.length - 1) return;

  state.historyIndex++;
  const next = state.history[state.historyIndex];
  restoreSnapshot(next);
  requestRender();
}

function createSnapshot(): Snapshot {
  return {
    crop: { ...state.crop },
    imageTransform: { ...state.imageTransform },
    mode: state.mode,
    aspectRatio: state.aspectRatio,
    exportW: state.exportW,
    exportH: state.exportH,
    activePresetKey: state.activePresetKey,
    timestamp: Date.now(),
  };
}

function restoreSnapshot(snap: Snapshot | undefined): void {
  if (!snap) return;

  state.crop = { ...snap.crop };
  state.imageTransform = { ...snap.imageTransform };
  state.mode = snap.mode;
  state.aspectRatio = snap.aspectRatio;
  state.exportW = snap.exportW;
  state.exportH = snap.exportH;
  state.activePresetKey = snap.activePresetKey;

  validateCrop(state.crop);

  updatePresetTriggers();
  syncExportInputsToCrop();
}

function areSnapshotsEqual(a: Snapshot, b: Snapshot): boolean {
  return (
    Math.abs(a.crop.x - b.crop.x) < EPSILON &&
    Math.abs(a.crop.y - b.crop.y) < EPSILON &&
    Math.abs(a.crop.w - b.crop.w) < EPSILON &&
    Math.abs(a.crop.h - b.crop.h) < EPSILON &&
    a.mode === b.mode &&
    Math.abs(a.aspectRatio - b.aspectRatio) < EPSILON
  );
}</file>

<file path="src/logic/resize.ts">
import { state, validateCrop } from '../state';
import { assert, clamp, hasChanged } from '../utils';
import { Mode, MIN_CROP, EPSILON } from '../constants';
import { Rect } from '../types';

export function moveCrop(next: Rect, dx: number, dy: number): void {
  const img = state.fullImage || state.image;
  if (!img) return;

  const maxX = Math.max(0, img.naturalWidth - next.w);
  const maxY = Math.max(0, img.naturalHeight - next.h);

  next.x = clamp(next.x + dx, 0, maxX);
  next.y = clamp(next.y + dy, 0, maxY);
}

export function resizeCrop(next: Rect, start: Rect, handle: string, dx: number, dy: number): void {
  const img = state.fullImage || state.image;
  if (!img) return;

  const locked = [Mode.ASPECT_RATIO, Mode.PIXEL_PRESET, Mode.CUSTOM_PIXEL].includes(state.mode);
  const r = locked ? state.aspectRatio : 0;

  if (!locked || r <= 0) {
    resizeFree(next, start, handle, dx, dy, img);
  } else if (handle.length === 2) {
    resizeCornerLocked(next, start, handle, dx, dy, img, r);
  } else {
    resizeEdgeLocked(next, start, handle, dx, dy, img, r);
  }
}

export function applyAspectToCrop(ratio: number): void {
  const img = state.fullImage || state.image;
  if (!img) return;
  
  // 1. Validate ratio
  if (ratio <= 0) return;

  const imgW = img.naturalWidth;
  const imgH = img.naturalHeight;

  // 2. Calculate max centered crop for this aspect ratio
  let w = imgW;
  let h = w / ratio;

  if (h > imgH) {
    h = imgH;
    w = h * ratio;
  }

  // 3. Update state
  state.crop = {
    x: (imgW - w) / 2,
    y: (imgH - h) / 2,
    w,
    h
  };
  
  validateCrop(state.crop);
}

// Internal helpers (same as previous step)
function resizeFree(next: Rect, start: Rect, handle: string, dx: number, dy: number, img: HTMLImageElement): void {
  let { x, y, w, h } = start;

  if (handle.includes("e")) w = clamp(start.w + dx, MIN_CROP, img.naturalWidth - start.x);
  if (handle.includes("w")) {
    const right = start.x + start.w;
    const maxDx = start.w - MIN_CROP;
    x = clamp(start.x + Math.min(dx, maxDx), 0, right - MIN_CROP);
    w = right - x;
  }
  if (handle.includes("s")) h = clamp(start.h + dy, MIN_CROP, img.naturalHeight - start.y);
  if (handle.includes("n")) {
    const bottom = start.y + start.h;
    const maxDy = start.h - MIN_CROP;
    y = clamp(start.y + Math.min(dy, maxDy), 0, bottom - MIN_CROP);
    h = bottom - y;
  }

  if (hasChanged(start, x, y, w, h)) Object.assign(next, { x, y, w, h });
}

function resizeCornerLocked(next: Rect, start: Rect, handle: string, dx: number, dy: number, img: HTMLImageElement, r: number): void {
  const startRight = start.x + start.w;
  const startBottom = start.y + start.h;
  const ax = handle.includes("w") ? startRight : start.x;
  const ay = handle.includes("n") ? startBottom : start.y;

  const rawDx = handle.includes("w") ? -dx : dx;
  let w = Math.max(MIN_CROP, start.w + rawDx);
  let h = w / r;

  let x = handle.includes("w") ? ax - w : ax;
  let y = handle.includes("n") ? ay - h : ay;

  // Boundary checks
  if (x < 0) { w = ax; h = w / r; x = 0; }
  if (y < 0) { h = ay; w = h * r; y = 0; }
  if (x + w > img.naturalWidth) { w = img.naturalWidth - x; h = w / r; }
  if (y + h > img.naturalHeight) { h = img.naturalHeight - y; w = h * r; }

  // Double check clamp
  if (x < 0) x = 0;
  if (y < 0) y = 0;
  if (x + w > img.naturalWidth) w = img.naturalWidth - x;
  if (y + h > img.naturalHeight) h = img.naturalHeight - y;

  if (w / r > h) w = h * r;
  else h = w / r;

  if (handle.includes("w")) x = ax - w;
  if (handle.includes("n")) y = ay - h;

  if (hasChanged(start, x, y, w, h)) Object.assign(next, { x, y, w, h });
}

function resizeEdgeLocked(next: Rect, start: Rect, handle: string, dx: number, dy: number, img: HTMLImageElement, r: number): void {
  const cx = start.x + start.w / 2;
  const cy = start.y + start.h / 2;
  const startRight = start.x + start.w;
  const startBottom = start.y + start.h;

  let x = start.x;
  let y = start.y;
  let w = start.w;
  let h = start.h;

  if (handle === "e" || handle === "w") {
    const sign = handle === "e" ? 1 : -1;
    let potentialW = start.w + dx * sign;
    const maxW_Img = handle === "e" ? img.naturalWidth - start.x : startRight;
    const maxH_Available = 2 * Math.min(cy, img.naturalHeight - cy);
    const maxW = Math.min(maxW_Img, maxH_Available * r);
    w = clamp(potentialW, MIN_CROP, maxW);
    h = w / r;
    y = cy - h / 2;
    x = handle === "e" ? start.x : startRight - w;
  } else if (handle === "n" || handle === "s") {
    const sign = handle === "s" ? 1 : -1;
    let potentialH = start.h + dy * sign;
    const maxH_Img = handle === "s" ? img.naturalHeight - start.y : startBottom;
    const maxW_Available = 2 * Math.min(cx, img.naturalWidth - cx);
    const maxH = Math.min(maxH_Img, maxW_Available / r);
    h = clamp(potentialH, MIN_CROP, maxH);
    w = h * r;
    x = cx - w / 2;
    y = handle === "s" ? start.y : startBottom - h;
  }

  if (hasChanged(start, x, y, w, h)) Object.assign(next, { x, y, w, h });
}</file>

<file path="src/logic/transform.ts">
import { state } from '../state';
import { CENTER_MARGIN, TRANSITION_MS, MIN_ZOOM, MAX_ZOOM, COMMIT_DELAY, EPSILON } from '../constants';
import { clamp } from '../utils';
import { requestRender } from '../ui/render';
import { pushHistory } from './history';

export function fitImageToViewport(): void {
  const img = state.image;
  if (!img) return;

  if (state.viewport.w === 0 || state.viewport.h === 0) {
    const vp = document.getElementById("viewport");
    if (vp) {
      state.viewport.w = vp.clientWidth;
      state.viewport.h = vp.clientHeight;
    }
  }

  const imgW = img.naturalWidth;
  const imgH = img.naturalHeight;
  const marginW = state.viewport.w * CENTER_MARGIN * 2;
  const marginH = state.viewport.h * CENTER_MARGIN * 2;

  const scale = Math.min(
    1,
    (state.viewport.w - marginW) / imgW,
    (state.viewport.h - marginH) / imgH,
  );
  
  state.baseScale = scale;
  state.zoom = 1.0;
  state.imageTransform.tx = (state.viewport.w - imgW * scale) / 2;
  state.imageTransform.ty = (state.viewport.h - imgH * scale) / 2;
}

export function recalculateLayout(): void {
  if (!state.image) return;
  const oldVpW = state.viewport.w;
  const oldVpH = state.viewport.h;
  const oldZoom = state.zoom;

  const viewport = document.getElementById("viewport");
  if (!viewport) return;
  state.viewport.w = viewport.clientWidth;
  state.viewport.h = viewport.clientHeight;

  if (oldVpW === 0 || oldVpH === 0) {
    fitImageToViewport();
    requestRender();
    return;
  }

  const oldScale = state.baseScale * oldZoom;
  const cx = (oldVpW / 2 - state.imageTransform.tx) / oldScale;
  const cy = (oldVpH / 2 - state.imageTransform.ty) / oldScale;

  fitImageToViewport();
  
  const newBaseScale = state.baseScale;
  const newScale = newBaseScale * oldZoom;
  const newTx = state.viewport.w / 2 - cx * newScale;
  const newTy = state.viewport.h / 2 - cy * newScale;

  animateToTransform({ tx: newTx, ty: newTy, zoom: oldZoom }, true);
}

export function computeCenteredTransform(): { tx: number; ty: number } | null {
  const img = state.image;
  if (!img) return null;

  const { x, y, w, h } = state.crop;
  const { tx, ty } = state.imageTransform;
  const currentScale = state.baseScale * state.zoom;
  
  const cropCxScreen = tx + ((x + w / 2) / state.previewScale) * currentScale;
  const cropCyScreen = ty + ((y + h / 2) / state.previewScale) * currentScale;

  const dx = (state.viewport.w / 2) - cropCxScreen;
  const dy = (state.viewport.h / 2) - cropCyScreen;

  return { tx: tx + dx, ty: ty + dy };
}

export function animateToTransform(target: { tx?: number; ty?: number; zoom?: number }, immediate = false): void {
  if (immediate) {
    if (target.tx !== undefined) state.imageTransform.tx = target.tx;
    if (target.ty !== undefined) state.imageTransform.ty = target.ty;
    if (target.zoom !== undefined) state.zoom = target.zoom;
    requestRender();
    return;
  }

  state.committing = true;
  requestRender();

  setTimeout(() => {
    if (target.tx !== undefined) state.imageTransform.tx = target.tx;
    if (target.ty !== undefined) state.imageTransform.ty = target.ty;
    if (target.zoom !== undefined) state.zoom = target.zoom;
    requestRender();

    setTimeout(() => {
      state.committing = false;
      requestRender();
    }, TRANSITION_MS + 30);
  }, 16);
}

export function setZoom(targetZoom: number, focalPoint: { x: number; y: number }): void {
  const newZoom = clamp(targetZoom, MIN_ZOOM, MAX_ZOOM);
  if (Math.abs(newZoom - state.zoom) < EPSILON) return;

  const s1 = state.baseScale * state.zoom;
  const s2 = state.baseScale * newZoom;
  const { tx: tx1, ty: ty1 } = state.imageTransform;
  
  const ix = (focalPoint.x - tx1) / s1;
  const iy = (focalPoint.y - ty1) / s1;

  const tx2 = focalPoint.x - ix * s2;
  const ty2 = focalPoint.y - iy * s2;

  animateToTransform({ tx: tx2, ty: ty2, zoom: newZoom }, true);
}

export function scheduleCommit(): void {
  if (state.commitTimer) clearTimeout(state.commitTimer);
  state.commitTimer = window.setTimeout(() => {
    state.commitTimer = null;
    if (!state.image) return;
    
    // History push on commit
    pushHistory("Commit Crop");
    
    const target = computeCenteredTransform();
    if (target) animateToTransform(target);
  }, COMMIT_DELAY);
}

export function zoomToFit(immediate = false): void {
  if (!state.image) return;
  const { w: cropW, h: cropH } = state.crop;
  const cropDisplayW = cropW / state.previewScale;
  const cropDisplayH = cropH / state.previewScale;

  const marginW = state.viewport.w * CENTER_MARGIN * 2;
  const marginH = state.viewport.h * CENTER_MARGIN * 2;

  if (cropDisplayW === 0 || cropDisplayH === 0) return;

  const targetZoom = Math.min(
    (state.viewport.w - marginW) / cropDisplayW / state.baseScale,
    (state.viewport.h - marginH) / cropDisplayH / state.baseScale,
  );

  const target = computeCenteredTransform();
  if (target) {
    animateToTransform({ ...target, zoom: targetZoom }, immediate);
  }
}</file>

<file path="src/main.ts">
import { initAppView } from './ui/init';
import { setAspect, toggleCustomAspect, applyCustomAspect } from './ui/aspect';
import { togglePreset, selectPreset, applyCustomPixel } from './ui/presets';
import { exportImage } from './ui/export';
import { resetCropToFull } from './logic/file-load';
import { state } from './state';
import { zoomToFit, setZoom, scheduleCommit } from './logic/transform';
import { requestRender } from './ui/render';

// Expose globals for HTML event handlers
(window as any).app = {
  setAspect,
  toggleCustomAspect,
  applyCustomAspect,
  togglePreset,
  selectPreset,
  applyCustomPixel,
  exportImage,
  
  resetCrop: () => {
    if (state.image) {
      resetCropToFull(state.fullImage || state.image);
      requestRender(); // Fix: Update immediately
      scheduleCommit(); // Fix: Center the image after reset
    }
  },
  
  toggleGrid: () => { 
    state.showGrid = !state.showGrid;
    requestRender(); // Fix: Update immediately
  },
  
  zoomToFit: () => {
    zoomToFit();
    requestRender();
  },
  
  zoomToActual: () => {
    setZoom(state.previewScale / state.baseScale, { x: state.viewport.w/2, y: state.viewport.h/2 });
    requestRender();
  },
  
  newImage: () => location.reload(),
  
  onExportInput: (dim: string, val: string) => {
    if (dim === 'w') state.exportW = val;
    else state.exportH = val;
    requestRender();
  }
};

document.addEventListener("DOMContentLoaded", () => {
  initAppView();
});</file>

<file path="src/state.ts">
import { Mode, MIN_CROP, EPSILON } from './constants';
import { Rect, Viewport, ImageTransform, DragState, Result, Ok, Err } from './types';

export interface Snapshot {
  crop: Rect;
  imageTransform: ImageTransform;
  mode: Mode;
  aspectRatio: number;
  exportW: string;
  exportH: string;
  activePresetKey: string | null;
  timestamp: number;
}

export interface AppState {
  image: HTMLImageElement | null;
  fullImage: HTMLImageElement | null;
  previewScale: number;
  crop: Rect;
  viewport: Viewport;
  imageTransform: ImageTransform;
  baseScale: number;
  zoom: number;
  drag: DragState | null;
  committing: boolean;
  commitTimer: number | null;
  needsRender: boolean;
  mode: Mode;
  aspectRatio: number;
  exportW: string;
  exportH: string;
  activePresetKey: string | null;
  presetLabels: Record<string, string>;
  customAspectActive: boolean;
  customAspectW: string;
  customAspectH: string;
  customAspectLabel: string;
  customPixelActive: boolean;
  customPixelW: string;
  customPixelH: string;
  showGrid: boolean;
  scaleFactor: number;
  scaleLevel: string;
  
  // History
  history: Snapshot[];
  historyIndex: number;
}

export const state: AppState = {
  image: null,
  fullImage: null,
  previewScale: 1,
  crop: { x: 0, y: 0, w: 0, h: 0 },
  viewport: { w: 0, h: 0 },
  imageTransform: { tx: 0, ty: 0 },
  baseScale: 1,
  zoom: 1,
  drag: null,
  committing: false,
  commitTimer: null,
  needsRender: false,
  mode: Mode.NONE,
  aspectRatio: 0,
  exportW: "",
  exportH: "",
  activePresetKey: null,
  presetLabels: {
    social: "Social Media",
    docs: "Documents",
    "custom-pixel": "Custom Pixels",
  },
  customAspectActive: false,
  customAspectW: "",
  customAspectH: "",
  customAspectLabel: "Custom",
  customPixelActive: false,
  customPixelW: "",
  customPixelH: "",
  showGrid: true,
  scaleFactor: 1,
  scaleLevel: "ok",
  
  history: [],
  historyIndex: -1,
};

export function validateCrop(crop: Rect): Result<boolean, string> {
  if (crop.x < -EPSILON) return Err("x must be >= 0");
  if (crop.y < -EPSILON) return Err("y must be >= 0");
  if (crop.w < MIN_CROP) return Err("w too small");
  if (crop.h < MIN_CROP) return Err("h too small");
  return Ok(true);
}

export function setMode(newMode: Mode): void {
  state.mode = newMode;
}

export function clearAllSelections(): void {
  state.mode = Mode.NONE;
  state.aspectRatio = 0;
  state.exportW = "";
  state.exportH = "";
  state.activePresetKey = null;
  state.customAspectActive = false;
  state.customAspectW = "";
  state.customAspectH = "";
  state.customAspectLabel = "Custom";
  state.customPixelActive = false;
  state.customPixelW = "";
  state.customPixelH = "";
  state.presetLabels.social = "Social Media";
  state.presetLabels.docs = "Documents";
  state.presetLabels["custom-pixel"] = "Custom Pixels";
}

export function markPresetActive(key: string, label: string): void {
  if (key in state.presetLabels) {
    state.activePresetKey = key;
    state.presetLabels[key] = label;
  }
}</file>

<file path="src/types.ts">
export type Result<T, E = Error> = 
  | { ok: true; value: T } 
  | { ok: false; error: E };

export const Ok = <T>(value: T): Result<T, never> => ({ ok: true, value });
export const Err = <E>(error: E): Result<never, E> => ({ ok: false, error });

export interface Point {
  x: number;
  y: number;
}

export interface Size {
  w: number;
  h: number;
}

export interface Rect extends Point, Size {}

export interface Viewport extends Size {}

export interface ImageTransform {
  tx: number;
  ty: number;
}

export interface DragState {
  handle: string;
  startScreen: Point;
  startCrop: Rect;
  startTransform: ImageTransform;
}</file>

<file path="src/ui/aspect.ts">
import { state, setMode, clearAllSelections } from '../state';
import { Mode, EPSILON } from '../constants';
import { requestRender } from './render';
import { scheduleCommit } from '../logic/transform';
import { applyAspectToCrop } from '../logic/resize';
import { validateAspectRatio, reduceRatio } from '../utils';
import { createPresetDropdowns } from './presets';

export function createAspectTools(): string {
  // Styles moved to CSS
  return `
    <div class="aspect-tools">
      <div class="aspect-pills">
        ${createAspectButtons()}
        <div class="divider-h"></div>
        ${createCustomAspectControl()}
        <div class="divider-h"></div>
        ${createPresetDropdowns()}
      </div>
    </div>
  `;
}

function createAspectButtons(): string {
  const ratios = [
    { label: "Free", value: 0 },
    { label: "1:1", value: 1 },
    { label: "4:3", value: 4/3 },
    { label: "3:2", value: 3/2 },
    { label: "16:9", value: 16/9 },
    { label: "9:16", value: 9/16 },
  ];

  return ratios.map(r => {
    const isActive = (state.mode === Mode.NONE && r.value === 0) ||
                     (state.mode === Mode.ASPECT_RATIO && Math.abs(state.aspectRatio - r.value) < EPSILON);
    return `<button class="aspect-pill ${isActive ? 'active' : ''}" onclick="window.app.setAspect(${r.value})">${r.label}</button>`;
  }).join("");
}

function createCustomAspectControl(): string {
  const isActive = state.customAspectActive;
  const hasCustom = state.mode === Mode.ASPECT_RATIO && state.customAspectLabel !== "Custom";
  const label = hasCustom ? state.customAspectLabel : "Custom";
  
  if (isActive) {
    return `
      <div class="custom-aspect-form">
        <input id="custom-aspect-w" type="number" min="1" placeholder="W" class="aspect-input" value="${state.customAspectW}">
        <span>:</span>
        <input id="custom-aspect-h" type="number" min="1" placeholder="H" class="aspect-input" value="${state.customAspectH}">
        <button class="btn-apply" onclick="window.app.applyCustomAspect()">�</button>
        <button class="btn-cancel" onclick="window.app.toggleCustomAspect()">?</button>
      </div>
    `;
  }
  return `<button class="aspect-pill ${isActive || hasCustom ? 'active' : ''}" onclick="window.app.toggleCustomAspect()">${label}</button>`;
}

export function setAspect(ratio: number): void {
  if (!state.image && ratio !== 0) return;
  clearAllSelections();
  
  if (ratio === 0) {
    setMode(Mode.NONE);
    state.aspectRatio = 0;
  } else {
    setMode(Mode.ASPECT_RATIO);
    state.aspectRatio = ratio;
    applyAspectToCrop(ratio);
  }
  
  requestRender();
  scheduleCommit();
}

export function toggleCustomAspect(): void {
  state.customAspectActive = !state.customAspectActive;
  if (!state.customAspectActive && state.mode === Mode.ASPECT_RATIO && state.customAspectLabel === "Custom") {
     setMode(Mode.NONE);
  }
  requestRender();
}

export function applyCustomAspect(): void {
  const wEl = document.getElementById("custom-aspect-w") as HTMLInputElement;
  const hEl = document.getElementById("custom-aspect-h") as HTMLInputElement;
  if (!wEl || !hEl) return;

  const w = parseInt(wEl.value, 10);
  const h = parseInt(hEl.value, 10);
  if (!(w > 0 && h > 0)) return;

  const reduced = reduceRatio(w, h);
  const ratio = reduced.w / reduced.h;
  
  if (validateAspectRatio(ratio).ok) {
    clearAllSelections();
    setMode(Mode.ASPECT_RATIO);
    state.aspectRatio = ratio;
    state.customAspectW = String(reduced.w);
    state.customAspectH = String(reduced.h);
    state.customAspectLabel = `${reduced.w}:${reduced.h}`;
    state.customAspectActive = false;
    
    applyAspectToCrop(ratio);
    requestRender();
    scheduleCommit();
  }
}</file>

<file path="src/ui/events.ts">
import { state } from '../state';
import { requestRender } from './render';
import { moveCrop, resizeCrop } from '../logic/resize';
import { scheduleCommit, setZoom, fitImageToViewport } from '../logic/transform';
import { resetCropToFull } from '../logic/file-load';
import { exportImage } from './export';
import { undo, redo } from '../logic/history';

export function bindCropView(): void {
  document.querySelectorAll("[data-handle]").forEach((el) => {
    (el as HTMLElement).onmousedown = (e) => startDrag(e, (el as HTMLElement).dataset.handle || "");
  });
  
  const area = document.getElementById("crop-area");
  if (area) area.onmousedown = (e) => startDrag(e, "move");

  const viewport = document.getElementById("viewport");
  if (viewport) {
    viewport.onwheel = handleWheelZoom as any;
    viewport.onmousedown = (e) => {
      if (e.target === viewport) startDrag(e, "pan-image");
    };
  }

  const slider = document.getElementById("zoom-slider");
  if (slider) slider.oninput = handleSliderZoom;

  document.addEventListener("keydown", handleKeyboard);
  document.addEventListener("mouseup", endDrag);
  document.addEventListener("mousemove", handleDrag);
}

function startDrag(e: MouseEvent, handle: string): void {
  if (!state.image) return;
  e.preventDefault();
  e.stopPropagation();

  state.committing = false;
  
  state.drag = {
    handle,
    startScreen: { x: e.clientX, y: e.clientY },
    startCrop: { ...state.crop },
    startTransform: { ...state.imageTransform }
  };
  
  const overlay = document.getElementById("crop-overlay");
  if (overlay) overlay.classList.add("dragging");

  requestRender();
}

function handleDrag(e: MouseEvent): void {
  if (!state.drag || !state.image) return;
  const { handle, startScreen, startCrop, startTransform } = state.drag;
  
  const currentScale = state.baseScale * state.zoom;
  if (currentScale <= 0) return;

  const dx = e.clientX - startScreen.x;
  const dy = e.clientY - startScreen.y;

  if (handle === "pan-image") {
    state.imageTransform.tx = startTransform.tx + dx;
    state.imageTransform.ty = startTransform.ty + dy;
  } else {
    const scaleFactor = state.previewScale / currentScale;
    const dxImg = dx * scaleFactor;
    const dyImg = dy * scaleFactor;
    
    const next = { ...startCrop };
    
    if (handle === "move") {
      moveCrop(next, dxImg, dyImg);
    } else {
      resizeCrop(next, startCrop, handle, dxImg, dyImg);
    }
    
    state.crop = next;
  }
  requestRender();
}

function endDrag(): void {
  if (!state.drag) return;
  
  const overlay = document.getElementById("crop-overlay");
  if (overlay) overlay.classList.remove("dragging");

  if (state.drag.handle !== "pan-image") {
    scheduleCommit();
  }
  
  state.drag = null;
  requestRender();
}

function handleKeyboard(e: KeyboardEvent): void {
  if ((e.target as HTMLElement).tagName === "INPUT") return;
  
  if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'z') {
    e.preventDefault();
    if (e.shiftKey) redo();
    else undo();
    return;
  }

  switch (e.key) {
    case "g": 
      state.showGrid = !state.showGrid; 
      requestRender(); 
      break;
    case "r": 
      if (state.image) { 
        resetCropToFull(state.fullImage || state.image); 
        scheduleCommit(); 
      } 
      break;
    case "f": 
      fitImageToViewport(); 
      requestRender();
      break;
    case "Enter": 
      if (e.metaKey || e.ctrlKey) exportImage(); 
      break;
  }
}

function handleWheelZoom(e: WheelEvent): void {
  if (!state.image) return;
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? -1 : 1;
  const zoomFactor = 1.1;
  const newZoom = state.zoom * (delta > 0 ? zoomFactor : 1 / zoomFactor);
  
  const rect = (e.currentTarget as Element).getBoundingClientRect();
  const focalPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  
  setZoom(newZoom, focalPoint);
}

function handleSliderZoom(e: Event): void {
  if (!state.image) return;
  const val = parseInt((e.target as HTMLInputElement).value, 10);
  const minLog = Math.log(0.1);
  const maxLog = Math.log(32.0);
  const scale = (maxLog - minLog) / 1000;
  const newZoom = Math.exp(minLog + scale * val);
  
  setZoom(newZoom, { x: state.viewport.w / 2, y: state.viewport.h / 2 });
}</file>

<file path="src/ui/export.ts">
import { state } from '../state';
import { Mode } from '../constants';
import { createExportBlob, generateFilename } from '../logic/export';

export function createExportTools(): string {
  // Styles moved to CSS
  return `
    <div class="export-tools">
      <div class="export-label">Export Size</div>
      <div class="export-size-inputs">
        <input id="export-w" class="size-input" oninput="window.app.onExportInput('w', this.value)">
        <span>x</span>
        <input id="export-h" class="size-input" oninput="window.app.onExportInput('h', this.value)">
      </div>
      <button class="export-action" onclick="window.app.exportImage()">Export</button>
    </div>
  `;
}

export function syncExportInputsToCrop(): void {
  const ew = document.getElementById("export-w") as HTMLInputElement;
  const eh = document.getElementById("export-h") as HTMLInputElement;
  if (!ew || !eh) return;
  
  if (state.mode === Mode.NONE || state.mode === Mode.ASPECT_RATIO) {
    if (document.activeElement !== ew) ew.value = Math.round(state.crop.w).toString();
    if (document.activeElement !== eh) eh.value = Math.round(state.crop.h).toString();
  } else if (state.mode === Mode.PIXEL_PRESET) {
    if (document.activeElement !== ew) ew.value = state.exportW;
    if (document.activeElement !== eh) eh.value = state.exportH;
  }
}

export function exportImage(): void {
  const w = parseInt(state.exportW) || Math.round(state.crop.w);
  const h = parseInt(state.exportH) || Math.round(state.crop.h);
  
  createExportBlob(w, h).then(blob => {
    if (!blob) return alert("Export failed");
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = generateFilename(w, h);
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 100);
  });
}</file>

<file path="src/ui/init.ts">
import { assert } from '../utils';
import { loadImageFile } from '../logic/file-load';
import { createCropView } from './layout';
import { bindCropView } from './events';
import { recalculateLayout } from '../logic/transform';

export function initAppView(): void {
  const app = document.getElementById("app");
  assert(!!app, "Missing #app");
  if (app) {
    app.innerHTML = createDropZone();
    bindDropZone();
  }
}

export function renderLoadingView(): void {
  const app = document.getElementById("app");
  if (app) app.innerHTML = `<div class="loading-view">Processing...</div>`;
}

export function renderCropView(): void {
  const app = document.getElementById("app");
  if (app) {
    app.innerHTML = createCropView();
    bindCropView();
    const vp = document.getElementById("viewport");
    if (vp) new ResizeObserver(() => recalculateLayout()).observe(vp);
  }
}

function createDropZone(): string {
  return `
    <div class="drop-zone" id="drop-zone">
      <input type="file" id="file-input" accept="image/*" class="hidden">
      <div>Drop image here</div>
    </div>
  `;
}

function bindDropZone(): void {
  const zone = document.getElementById("drop-zone");
  const input = document.getElementById("file-input") as HTMLInputElement;
  if (!zone || !input) return;

  zone.onclick = () => input.click();
  input.onchange = (e: any) => {
    if (e.target.files?.length) loadImageFile(e.target.files[0]);
  };
  zone.ondragover = (e) => { e.preventDefault(); zone.classList.add("dragging"); };
  zone.ondragleave = () => zone.classList.remove("dragging");
  zone.ondrop = (e) => {
    e.preventDefault();
    zone.classList.remove("dragging");
    if (e.dataTransfer?.files.length) loadImageFile(e.dataTransfer.files[0]);
  };
}</file>

<file path="src/ui/layout.ts">
import { createAspectTools } from './aspect';
import { createExportTools } from './export';

export function createCropView(): string {
  // Ensure we call createAspectTools() which now definitely includes the preset dropdowns
  return `
    <div class="viewport" id="viewport">
      <canvas id="canvas"></canvas>
      <div class="crop-overlay" id="crop-overlay">
        <div class="crop-area" id="crop-area"></div>
        ${createHandles()}
        <canvas id="grid-canvas" class="grid-canvas"></canvas>
      </div>
      ${createCropMetadata()}
      ${createAspectTools()}
      ${createExportTools()}
    </div>
    ${createTopBar()}
    ${createBottomBar()}
  `;
}

function createHandles(): string {
  return `
    <div class="handle nw" data-handle="nw"></div><div class="handle ne" data-handle="ne"></div>
    <div class="handle sw" data-handle="sw"></div><div class="handle se" data-handle="se"></div>
    <div class="edge n" data-handle="n"></div><div class="edge s" data-handle="s"></div>
    <div class="edge w" data-handle="w"></div><div class="edge e" data-handle="e"></div>
  `;
}

function createTopBar(): string {
  return `
    <div class="top-bar">
      <div class="top-bar-left">
        <div class="info-pill" id="source-info">-</div>
        <div class="info-pill" id="crop-info">-</div>
      </div>
      <div class="top-bar-right">
        <button class="tool-btn" onclick="window.app.newImage()" title="New Image">N</button>
      </div>
    </div>
  `;
}

function createBottomBar(): string {
  return `
    <div class="bottom-bar">
      <button class="tool-btn" onclick="window.app.toggleGrid()" title="Grid">G</button>
      <div class="zoom-group">
        <button class="tool-btn" onclick="window.app.zoomToFit()" title="Fit">Fit</button>
        <input type="range" id="zoom-slider" min="0" max="1000" step="1">
        <div id="zoom-indicator">100%</div>
        <button class="tool-btn" onclick="window.app.zoomToActual()" title="1:1">1:1</button>
      </div>
      <button class="tool-btn" onclick="window.app.resetCrop()" title="Reset">R</button>
    </div>
  `;
}

function createCropMetadata(): string {
  return `
    <div class="crop-metadata" id="crop-metadata">
      <div class="metadata-value" id="crop-dimensions">-</div>
      <div class="metadata-arrow"></div>
      <div class="metadata-value" id="export-dimensions">-</div>
      <div class="metadata-note" id="scale-note"></div>
    </div>
  `;
}</file>

<file path="src/ui/presets.ts">
import { state, setMode, clearAllSelections, markPresetActive } from '../state';
import { Mode } from '../constants';
import { applyAspectToCrop } from '../logic/resize';
import { requestRender } from './render';
import { scheduleCommit } from '../logic/transform';
import { validatePixelDimension, validateAspectRatio } from '../utils';

export function createPresetDropdowns(): string {
  // We need to replicate the HTML structure for the 3 menus: Social, Docs, Custom Pixel
  return `
    <div class="preset-group">
      <button id="preset-social-trigger" class="aspect-pill preset-trigger" onclick="window.app.togglePreset('social', event)">
        <span>${state.presetLabels.social}</span> ?
      </button>
      <div id="preset-menu-social" class="preset-menu">
        ${createSocialItems()}
      </div>
    </div>

    <div class="preset-group">
      <button id="preset-docs-trigger" class="aspect-pill preset-trigger" onclick="window.app.togglePreset('docs', event)">
        <span>${state.presetLabels.docs}</span> ?
      </button>
      <div id="preset-menu-docs" class="preset-menu">
        ${createDocsItems()}
      </div>
    </div>

    <div class="preset-group">
      <button id="preset-custom-trigger" class="aspect-pill preset-trigger" onclick="window.app.togglePreset('custom-pixel', event)">
        <span>${state.presetLabels["custom-pixel"]}</span> ?
      </button>
      <div id="preset-menu-custom-pixel" class="preset-menu ${state.customPixelActive ? 'visible' : ''}">
        ${createCustomPixelForm()}
      </div>
    </div>
  `;
}

function createSocialItems(): string {
  return `
    <div class="preset-group-label">Instagram</div>
    ${btn('social', 'IG Square', 1080, 1080)}
    ${btn('social', 'IG Portrait', 1080, 1350)}
    ${btn('social', 'IG Landscape', 1080, 566)}
    ${btn('social', 'IG Story', 1080, 1920)}
    <div class="preset-group-label">Facebook</div>
    ${btn('social', 'FB Post', 1080, 1080)}
    ${btn('social', 'FB Cover', 820, 312)}
    <div class="preset-group-label">YouTube</div>
    ${btn('social', 'YT Thumb', 1280, 720)}
  `;
}

function createDocsItems(): string {
  return `
    <div class="preset-group-label">Print @300dpi</div>
    ${btn('docs', 'A4', 2480, 3508)}
    ${btn('docs', 'Letter', 2550, 3300)}
  `;
}

function btn(key: string, label: string, w: number, h: number): string {
  return `<button class="preset-item" onclick="window.app.selectPreset('${key}', '${label}', ${w}, ${h})">${label} ${w}x${h}</button>`;
}

function createCustomPixelForm(): string {
  return `
    <div class="preset-group-label">Custom Size</div>
    <div class="custom-pixel-form">
      <input id="custom-pixel-w" type="number" placeholder="W" class="aspect-input" value="${state.customPixelW}">
      <span>x</span>
      <input id="custom-pixel-h" type="number" placeholder="H" class="aspect-input" value="${state.customPixelH}">
      <button class="btn-apply" onclick="window.app.applyCustomPixel()">Apply</button>
    </div>
  `;
}

export function togglePreset(key: string, e: Event): void {
  e.stopPropagation();
  const menu = document.getElementById(`preset-menu-${key}`);
  const wasVisible = menu?.classList.contains("visible");
  
  // Close all
  document.querySelectorAll(".preset-menu").forEach(el => el.classList.remove("visible"));
  
  if (!wasVisible && menu) {
    menu.classList.add("visible");
    if (key === 'custom-pixel') state.customPixelActive = true;
  } else {
    state.customPixelActive = false;
  }
  requestRender();
}

export function selectPreset(key: string, label: string, w: number, h: number): void {
  if (!state.image) return;
  
  clearAllSelections();
  setMode(Mode.PIXEL_PRESET);
  markPresetActive(key, label);
  
  // Close menus
  document.querySelectorAll(".preset-menu").forEach(el => el.classList.remove("visible"));

  state.exportW = String(w);
  state.exportH = String(h);
  
  const ratio = w / h;
  state.aspectRatio = ratio;
  
  applyAspectToCrop(ratio);
  requestRender();
  scheduleCommit();
}

export function applyCustomPixel(): void {
  const wEl = document.getElementById("custom-pixel-w") as HTMLInputElement;
  const hEl = document.getElementById("custom-pixel-h") as HTMLInputElement;
  if (!wEl || !hEl) return;
  
  const w = parseInt(wEl.value, 10);
  const h = parseInt(hEl.value, 10);
  if (!(w > 0 && h > 0)) return;

  clearAllSelections();
  setMode(Mode.CUSTOM_PIXEL);
  state.customPixelW = String(w);
  state.customPixelH = String(h);
  markPresetActive('custom-pixel', `Custom ${w}x${h}`);
  
  document.querySelectorAll(".preset-menu").forEach(el => el.classList.remove("visible"));
  state.customPixelActive = false;

  state.exportW = String(w);
  state.exportH = String(h);
  state.aspectRatio = w / h;

  applyAspectToCrop(state.aspectRatio);
  requestRender();
  scheduleCommit();
}

export function updatePresetTriggers(): void {
  const map: Record<string, string> = {
    social: "preset-social-trigger",
    docs: "preset-docs-trigger",
    "custom-pixel": "preset-custom-trigger",
  };
  
  Object.entries(map).forEach(([key, id]) => {
    const el = document.getElementById(id);
    if (!el) return;
    
    const span = el.querySelector("span");
    if (span) span.textContent = state.presetLabels[key] || "Preset";
    
    if (state.activePresetKey === key) el.classList.add("active");
    else el.classList.remove("active");
  });
}</file>

<file path="src/ui/render.ts">
import { state } from '../state';
import { updateCropInfoUI } from './updates';
import { updatePresetTriggers } from './presets';
import { syncExportInputsToCrop } from './export';
import { updateZoomUI } from './updates';

export function requestRender(): void {
  if (state.needsRender) return;
  state.needsRender = true;
  requestAnimationFrame(() => {
    state.needsRender = false;
    renderFrame();
  });
}

function renderFrame(): void {
  const img = state.image;
  if (!img) return;

  const canvas = document.getElementById("canvas") as HTMLCanvasElement;
  const overlay = document.getElementById("crop-overlay");
  if (!canvas || !overlay) return;

  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  if (canvas.width !== img.naturalWidth || canvas.height !== img.naturalHeight) {
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);
  }

  const { tx, ty } = state.imageTransform;
  const { x, y, w, h } = state.crop;
  const currentScale = state.baseScale * state.zoom;

  // CRITICAL FIX: Add image rendering logic for sharp/crisp edges when zoomed
  const screenPixelsPerImagePixel = currentScale / state.previewScale;
  canvas.style.imageRendering = screenPixelsPerImagePixel > 2.5 ? "pixelated" : "auto";

  canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${currentScale})`;
  canvas.className = state.committing ? "canvas-committing" : "";
  overlay.className = getOverlayClass();

  updateOverlayStyle(overlay, x, y, w, h, tx, ty, currentScale);
  
  const gridCanvas = document.getElementById("grid-canvas") as HTMLCanvasElement;
  if (gridCanvas) renderGrid(gridCanvas, w * currentScale / state.previewScale, h * currentScale / state.previewScale);

  updateCropInfoUI();
  updatePresetTriggers();
  syncExportInputsToCrop();
  updateZoomUI();
}

function getOverlayClass(): string {
  if (state.committing) return "crop-overlay committing";
  if (state.drag) return "crop-overlay dragging";
  return "crop-overlay";
}

function updateOverlayStyle(overlay: HTMLElement, x: number, y: number, w: number, h: number, tx: number, ty: number, scale: number) {
  const pScale = state.previewScale;
  const l = tx + (x / pScale) * scale;
  const t = ty + (y / pScale) * scale;
  overlay.style.left = `${l}px`;
  overlay.style.top = `${t}px`;
  overlay.style.width = `${(w / pScale) * scale}px`;
  overlay.style.height = `${(h / pScale) * scale}px`;
}

function renderGrid(canvas: HTMLCanvasElement, w: number, h: number): void {
  if (!state.showGrid) {
    canvas.style.display = "none";
    return;
  }
  canvas.style.display = "block";
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
  const ctx = canvas.getContext("2d");
  if (!ctx) return;
  
  ctx.clearRect(0, 0, w, h);
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  
  ctx.moveTo(w / 3, 0); ctx.lineTo(w / 3, h);
  ctx.moveTo(2 * w / 3, 0); ctx.lineTo(2 * w / 3, h);
  ctx.moveTo(0, h / 3); ctx.lineTo(w, h / 3);
  ctx.moveTo(0, 2 * h / 3); ctx.lineTo(w, 2 * h / 3);
  
  ctx.stroke();
}</file>

<file path="src/ui/updates.ts">
import { state } from '../state';
import { gcd } from '../utils';

export function updateCropInfoUI(): void {
  const info = document.getElementById("crop-dimensions");
  const exportDim = document.getElementById("export-dimensions");
  
  if (!state.image) return;

  const w = Math.round(state.crop.w);
  const h = Math.round(state.crop.h);
  
  if (info) {
    const g = gcd(w, h);
    info.textContent = `${w}x${h} (${w/g}:${h/g})`;
  }

  if (exportDim) {
    const ew = parseInt(state.exportW) || w;
    const eh = parseInt(state.exportH) || h;
    exportDim.textContent = `${ew}x${eh}`;
  }
}

export function updateZoomUI(): void {
  const ind = document.getElementById("zoom-indicator");
  if (ind) ind.textContent = `${Math.round(state.zoom * 100)}%`;
}</file>

<file path="src/utils.ts">
import { Result, Ok, Err } from './types';
import { EPSILON, MAX_PIXEL_DIM } from './constants';

export function assert(cond: boolean, msg: string): void {
  if (!cond) throw new Error(`Assertion failed: ${msg}`);
}

export function clamp(val: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, val));
}

export function gcd(a: number, b: number): number {
  let x = Math.abs(a);
  let y = Math.abs(b);
  while (y) {
    const t = y;
    y = x % y;
    x = t;
  }
  return x;
}

export function reduceRatio(w: number, h: number): { w: number; h: number } {
  if (w <= 0 || h <= 0) return { w: 0, h: 0 };
  const divisor = gcd(w, h) || 1;
  return { w: w / divisor, h: h / divisor };
}

export function validateAspectRatio(ratio: number): Result<boolean, string> {
  if (ratio < 0) return Err("Ratio must be positive");
  if (ratio > 100) return Err("Ratio exceeds maximum");
  return Ok(true);
}

export function validatePixelDimension(dim: number): Result<boolean, string> {
  if (dim <= 0) return Err("Dimension must be > 0");
  if (dim > MAX_PIXEL_DIM) return Err("Dimension exceeds limit");
  if (!Number.isInteger(dim)) return Err("Dimension must be integer");
  return Ok(true);
}

export function hasChanged(start: any, x: number, y: number, w: number, h: number): boolean {
  const threshold = 0.25;
  return (
    Math.abs(start.x - x) >= threshold ||
    Math.abs(start.y - y) >= threshold ||
    Math.abs(start.w - w) >= threshold ||
    Math.abs(start.h - h) >= threshold
  );
}</file>

<file path="styles.css">
:root {
    --bg-color: #0a0a0a;
    --panel-bg: rgba(18, 18, 20, 0.95);
    --border-color: #2a2a2c;
    --border-subtle: #1a1a1c;
    --text-color: #e8e8e8;
    --text-muted-color: #888;
    --text-dark-color: #0a0a0a;
    --accent-color: #ffffff;
    --accent-hover: #f0f0f0;
    --button-bg: #1e1e20;
    --button-hover: #2a2a2c;
    --input-bg: #141416;
    --success-color: #6ccf6c;
    --warning-color: #e0c75a;
    --error-color: #ff6666;

    --font-family:
        -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
    --font-mono: "SF Mono", "Monaco", "Cascadia Code", "Courier New", monospace;
    --font-size-xs: 10px;
    --font-size-sm: 11px;
    --font-size-md: 12px;
    --font-size-base: 13px;

    --spacing-xs: 4px;
    --spacing-sm: 6px;
    --spacing-md: 8px;
    --spacing-lg: 10px;
    --spacing-xl: 14px;

    --radius-sm: 4px;
    --radius-md: 6px;
    --radius-lg: 8px;
    --radius-pill: 20px;
    --transition-fast: 0.1s ease-out;
    --transition-base: 0.15s ease-in-out;

    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.4);
    --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.5);
    --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.6);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-family);
    background: var(--bg-color);
    color: var(--text-color);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    font-size: var(--font-size-base);
    line-height: 1.4;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#app {
    width: 100vw;
    height: 100vh;
    position: relative;
}

.viewport {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    cursor: grab;
}

.viewport:active {
    cursor: grabbing;
}

.viewport canvas {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
    pointer-events: none;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
}

.canvas-committing {
    transition: transform 500ms cubic-bezier(0.33, 0, 0.17, 1);
}

.drop-zone,
.loading-view {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    color: var(--text-muted-color);
    font-size: 15px;
    font-weight: 500;
}

.drop-zone {
    cursor: pointer;
    transition: background 0.2s ease;
}

.drop-zone:hover,
.drop-zone.dragging {
    background: rgba(255, 255, 255, 0.02);
    color: var(--text-color);
}

/* TOP BAR */
.top-bar {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-lg);
    pointer-events: none;
    z-index: 100;
}

.top-bar-left,
.top-bar-right {
    display: flex;
    gap: var(--spacing-md);
    pointer-events: auto;
}

.info-pill {
    padding: 5px 11px;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-pill);
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    font-weight: 600;
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-sm);
    color: var(--text-color);
}

/* BOTTOM BAR */
.bottom-bar {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: var(--spacing-lg);
    padding: var(--spacing-lg);
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-lg);
    pointer-events: auto;
    z-index: 100;
}

.zoom-group {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
}

#zoom-slider {
    -webkit-appearance: none;
    width: 120px;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    cursor: pointer;
}

#zoom-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: var(--accent-color);
    border-radius: 50%;
    cursor: pointer;
}

#zoom-slider::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: var(--accent-color);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

#zoom-indicator {
    font-family: var(--font-mono);
    font-size: var(--font-size-sm);
    font-weight: 600;
    min-width: 40px;
    text-align: center;
}

.tool-btn {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--button-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    cursor: pointer;
    color: var(--text-muted-color);
    transition: all var(--transition-fast);
}

.tool-btn:hover {
    color: var(--text-color);
    background: var(--button-hover);
    border-color: var(--border-color);
}

/* CROP OVERLAY */
.crop-overlay {
    position: absolute;
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.92);
    pointer-events: none;
    transition: box-shadow var(--transition-base);
}

.crop-overlay.dragging {
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.95);
}

.crop-overlay.committing {
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.92);
    transition:
        left 500ms cubic-bezier(0.33, 0, 0.17, 1),
        top 500ms cubic-bezier(0.33, 0, 0.17, 1),
        width 500ms cubic-bezier(0.33, 0, 0.17, 1),
        height 500ms cubic-bezier(0.33, 0, 0.17, 1),
        box-shadow var(--transition-base);
}

.crop-area {
    position: absolute;
    inset: 0;
    cursor: move;
    pointer-events: auto;
}

.handle,
.edge {
    pointer-events: auto;
    transition: all var(--transition-fast);
}

.handle {
    position: absolute;
    width: 11px;
    height: 11px;
    background: var(--accent-color);
    border: 2px solid var(--bg-color);
    border-radius: 2px;
    box-shadow: var(--shadow-sm);
}

.handle:hover {
    width: 13px;
    height: 13px;
}

.handle.nw { top: -6px; left: -6px; cursor: nwse-resize; }
.handle.ne { top: -6px; right: -6px; cursor: nesw-resize; }
.handle.sw { bottom: -6px; left: -6px; cursor: nesw-resize; }
.handle.se { bottom: -6px; right: -6px; cursor: nwse-resize; }

.edge {
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    opacity: 0;
    transition: opacity var(--transition-fast);
}

.crop-overlay:hover .edge {
    opacity: 1;
}

.edge.n, .edge.s {
    width: 36px;
    height: 5px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
    border-radius: 3px;
}
.edge.n { top: -3px; }
.edge.s { bottom: -3px; }

.edge.w, .edge.e {
    width: 5px;
    height: 36px;
    top: 50%;
    transform: translateY(-50%);
    cursor: ew-resize;
    border-radius: 3px;
}
.edge.w { left: -3px; }
.edge.e { right: -3px; }

.grid-canvas {
    position: absolute;
    inset: 0;
    pointer-events: none;
}

/* CROP METADATA */
.crop-metadata {
    position: absolute;
    top: -36px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 7px;
    padding: 4px 10px;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-pill);
    font-family: var(--font-mono);
    font-size: var(--font-size-xs);
    font-weight: 600;
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-sm);
    opacity: 0;
    pointer-events: none;
    transition: opacity var(--transition-base);
    white-space: nowrap;
}

.crop-overlay:hover .crop-metadata {
    opacity: 1;
}

.metadata-value { color: var(--text-color); }
.metadata-arrow { color: var(--text-muted-color); }

.metadata-note {
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 9px;
    font-weight: 700;
}
.metadata-note.ok { color: var(--success-color); background: rgba(108, 207, 108, 0.15); }
.metadata-note.warn { color: var(--warning-color); background: rgba(224, 199, 90, 0.15); }
.metadata-note.bad { color: var(--error-color); background: rgba(255, 102, 102, 0.15); }

/* ASPECT TOOLS - FIXED POSITION */
.aspect-tools {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    opacity: 1;
    pointer-events: auto;
    z-index: 500;
    transition: opacity var(--transition-base);
}

.aspect-pills {
    display: flex;
    flex-direction: column;
    gap: 3px;
    padding: 5px;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
    backdrop-filter: blur(20px) saturate(120%);
    box-shadow: var(--shadow-md);
}

.aspect-pill {
    padding: 5px 9px;
    border-radius: var(--radius-sm);
    border: 1px solid transparent;
    background: transparent;
    color: var(--text-muted-color);
    cursor: pointer;
    font-family: var(--font-mono);
    font-size: var(--font-size-xs);
    font-weight: 600;
    transition: all var(--transition-fast);
    white-space: nowrap;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 4px;
}

.aspect-pill:hover {
    color: var(--text-color);
    background: rgba(255, 255, 255, 0.05);
}

.aspect-pill.active {
    background: rgba(255, 255, 255, 0.12);
    color: var(--accent-color);
    border-color: rgba(255, 255, 255, 0.15);
}

.divider-h {
    height: 1px;
    background: var(--border-subtle);
    margin: 2px 0;
}

.custom-aspect-form {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 3px;
}

.aspect-input {
    width: 40px;
    padding: 3px 5px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-subtle);
    background: var(--input-bg);
    color: var(--text-color);
    font-size: var(--font-size-xs);
    text-align: center;
    font-family: var(--font-mono);
    font-weight: 600;
}

.btn-apply, .btn-cancel {
    padding: 3px 6px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-subtle);
    background: var(--button-bg);
    color: var(--text-color);
    cursor: pointer;
    font-size: var(--font-size-xs);
    font-weight: 600;
}

/* EXPORT TOOLS - BOTTOM RIGHT FIXED */
.export-tools {
    position: fixed;
    right: 20px;
    bottom: 80px;
    top: auto;
    transform: none;
    opacity: 1;
    pointer-events: auto;
    z-index: 500;
    background: var(--panel-bg);
    padding: 10px;
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(20px);
}

.export-label {
    font-size: var(--font-size-xs);
    color: var(--text-muted-color);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 600;
    padding: 0 5px;
}

.export-size-inputs {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 9px;
    background: var(--panel-bg);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-md);
}

.size-input {
    width: 52px;
    padding: 3px 6px;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-subtle);
    background: var(--input-bg);
    color: var(--text-color);
    font-size: var(--font-size-sm);
    text-align: center;
    font-family: var(--font-mono);
    font-weight: 600;
}

.export-action {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 9px 14px;
    background: var(--accent-color);
    color: var(--text-dark-color);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-family: var(--font-family);
    font-size: var(--font-size-sm);
    font-weight: 700;
    transition: all var(--transition-fast);
}

.export-action:hover {
    background: var(--accent-hover);
    transform: translateY(-1px);
}

.hidden { display: none !important; }</file>

<file path="stylesControls.css">
/* FILE: crop/stylesControls.css */

.btn {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    cursor: pointer;
    font-family: "Courier New", monospace;
    font-size: 9px;
    transition: all 0.15s ease-in-out;
}

.btn:hover {
    border-color: #666;
    background: #222;
}

.btn-primary {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.btn-primary:hover {
    background: #ddd;
    border-color: #ddd;
}

.grid-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 9px;
    color: #888;
    cursor: pointer;
}

.grid-toggle input[type="checkbox"] {
    cursor: pointer;
}

.preset-label {
    font-size: 9px;
    color: #888;
}

.preset-dropdown {
    position: relative;
}

.preset-trigger {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 9px;
    cursor: pointer;
    transition: all 0.15s ease-in-out;
    min-width: 120px;
    justify-content: space-between;
}

.preset-trigger:hover {
    border-color: #666;
    background: #222;
}

.preset-trigger.active {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.preset-trigger.pulsing {
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%,
    100% {
        opacity: 1;
    }
    50% {
        opacity: 0.7;
    }
}

.preset-menu {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 6px;
    display: none;
    flex-direction: column;
    gap: 2px;
    min-width: 200px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 100;
}

.preset-menu.visible {
    display: flex;
}

.preset-group-label {
    font-size: 8px;
    color: #666;
    padding: 6px 8px 2px 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.preset-item {
    padding: 6px 8px;
    font-size: 9px;
    color: #fff;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.1s ease-in-out;
}

.preset-item:hover {
    background: #333;
}

.custom-pixel-inline {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 8px;
}

.custom-aspect-inline {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-left: 4px;
}

.custom-aspect-input {
    width: 40px;
    padding: 2px 3px;
    border-radius: 4px;
    border: 1px solid #444;
    background: #111;
    color: #fff;
    font-size: 9px;
    text-align: center;
    font-family: "Courier New", monospace;
}

.top-right-label {
    font-size: 9px;
    color: #888;
}

.dim-field {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.dim-caption {
    font-size: 7px;
    color: #666;
    text-transform: uppercase;
}

.export-input {
    width: 60px;
    padding: 4px 6px;
    border-radius: 4px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 10px;
    font-family: "Courier New", monospace;
}

.export-input:focus {
    outline: none;
    border-color: #fff;
}

.scale-indicator {
    margin-left: 6px;
    font-size: 8px;
    color: #888;
}

.scale-indicator.hidden {
    display: none;
}

.scale-indicator.ok {
    color: #6ccf6c;
}

.scale-indicator.warn {
    color: #e0c75a;
}

.scale-indicator.bad {
    color: #ff6666;
}

.aspect-btn {
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1a1a1a;
    color: #fff;
    font-size: 9px;
    cursor: pointer;
    font-family: "Courier New", monospace;
    transition: all 0.15s ease-in-out;
}

.aspect-btn:hover {
    border-color: #fff;
    background: rgba(255, 255, 255, 0.06);
}

.aspect-btn.active {
    background: #fff;
    color: #000;
    border-color: #fff;
}

.aspect-btn.pulsing {
    animation: pulse 2s ease-in-out infinite;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}</file>

<file path="warden.toml">
# warden.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 5
max_nesting_depth = 2
max_function_args = 5
max_function_words = 5
ignore_naming_on = ["tests", "spec"]

# Commands are auto-detected if not specified here.
# To override:
# [commands]
# check = "npx.cmd @biomejs/biome check src/"
</file>

